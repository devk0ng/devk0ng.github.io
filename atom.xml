<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>devk0ng&#39;s blog</title>
  
  <subtitle>Slow and Steady! This is my development study note</subtitle>
  <link href="https://devk0ng.github.io/atom.xml" rel="self"/>
  
  <link href="https://devk0ng.github.io/"/>
  <updated>2022-02-15T16:10:01.015Z</updated>
  <id>https://devk0ng.github.io/</id>
  
  <author>
    <name>Sungbin Hong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ansible이란?</title>
    <link href="https://devk0ng.github.io/2022/02/16/ansible/"/>
    <id>https://devk0ng.github.io/2022/02/16/ansible/</id>
    <published>2022-02-15T16:08:33.309Z</published>
    <updated>2022-02-15T16:10:01.015Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Ansible-이란&quot;&gt;&lt;a href=&quot;#Ansible-이란&quot; class=&quot;headerlink&quot; title=&quot;Ansible 이란?&quot;&gt;&lt;/a&gt;Ansible 이란?&lt;/h1&gt;&lt;p&gt;기존엔 프로그램이 돌아가기 위한 실행환경을 만드는 데에 쉘 스크립트를 일반적으로 사용했어.&lt;/p&gt;
&lt;p&gt;쉘 스크립트에 설치하고자하는 패키지나 혹은 그 외 다른 명령어들의 나열을 통해 원하고자 하는 실행흐름을 만들었지.&lt;/p&gt;
&lt;p&gt;하지만 요즈음 여러 기술들의 발전과 함께 관리해야하는 서버의 숫자가 급격하게 증가하고 있어.&lt;/p&gt;
&lt;p&gt;이러한 상황속에서 단순 쉘 스크립트만으로는 관리하기에 어려운 상황인거지.&lt;/p&gt;</summary>
    
    
    
    <category term="deploy" scheme="https://devk0ng.github.io/categories/deploy/"/>
    
    
    <category term="ansible" scheme="https://devk0ng.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>커버로스(kerberos) 인증이란</title>
    <link href="https://devk0ng.github.io/2022/02/14/kerberos/"/>
    <id>https://devk0ng.github.io/2022/02/14/kerberos/</id>
    <published>2022-02-14T03:01:13.829Z</published>
    <updated>2022-02-14T03:02:37.855Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;커버로스-kerberos-인증이란&quot;&gt;&lt;a href=&quot;#커버로스-kerberos-인증이란&quot; class=&quot;headerlink&quot; title=&quot;커버로스(kerberos) 인증이란&quot;&gt;&lt;/a&gt;커버로스(kerberos) 인증이란&lt;/h1&gt;&lt;br/&gt;

&lt;h1 id=&quot;커버로스-인증이란&quot;&gt;&lt;a href=&quot;#커버로스-인증이란&quot; class=&quot;headerlink&quot; title=&quot;커버로스 인증이란?&quot;&gt;&lt;/a&gt;커버로스 인증이란?&lt;/h1&gt;&lt;p&gt;커버로스는 티켓이라는 개념을 기반으로 인증을 하여 안전한 통신을 제공하기 위한 프로토콜이라고 생각하면 될 것 같애. 자세한 과정은 아래에 그림과 함께 그려보도록 하자!&lt;/p&gt;</summary>
    
    
    
    <category term="authentication" scheme="https://devk0ng.github.io/categories/authentication/"/>
    
    
    <category term="kerberos" scheme="https://devk0ng.github.io/tags/kerberos/"/>
    
  </entry>
  
  <entry>
    <title>git pull, fetch, tag의 원리</title>
    <link href="https://devk0ng.github.io/2022/02/13/git_fetch_pull_tag/"/>
    <id>https://devk0ng.github.io/2022/02/13/git_fetch_pull_tag/</id>
    <published>2022-02-13T14:21:56.100Z</published>
    <updated>2022-02-13T14:23:01.841Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;git-pull-fetch-tag의-원리&quot;&gt;&lt;a href=&quot;#git-pull-fetch-tag의-원리&quot; class=&quot;headerlink&quot; title=&quot;git pull, fetch, tag의 원리&quot;&gt;&lt;/a&gt;git pull, fetch, tag의 원리&lt;/h1&gt;&lt;h1 id=&quot;git-remote-repository-원격저장소&quot;&gt;&lt;a href=&quot;#git-remote-repository-원격저장소&quot; class=&quot;headerlink&quot; title=&quot;git remote repository (원격저장소)&quot;&gt;&lt;/a&gt;git remote repository (원격저장소)&lt;/h1&gt;&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;원격저장소란&quot;&gt;&lt;a href=&quot;#원격저장소란&quot; class=&quot;headerlink&quot; title=&quot;원격저장소란?&quot;&gt;&lt;/a&gt;원격저장소란?&lt;/h2&gt;&lt;p&gt;원격저장소는 현재 로컬 레파지토리에서 연결할 대상이라고 볼 수 있어.&lt;/p&gt;
&lt;p&gt;연결을 했다는 것은 git 명령어(push, pull, fetch)를 통해 연결된 외부 레파지토리에 현재 작업한 로컬 레파지토리의 내용을 반영하거나 혹은 외부 레파지토리의 내용을 가져올 수 있게 되는 것을 뜻해.&lt;/p&gt;
&lt;p&gt;이 원격저장소에 대해 전문적으로 서비스 해주는 녀석이 바로 Git hub야.&lt;/p&gt;
&lt;p&gt;자신이 직접 저장소를 만들어서 관리할 수도 있어!! &lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://devk0ng.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://devk0ng.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git branch와 reset의 원리</title>
    <link href="https://devk0ng.github.io/2022/02/07/git_branch_reset/"/>
    <id>https://devk0ng.github.io/2022/02/07/git_branch_reset/</id>
    <published>2022-02-06T15:50:22.005Z</published>
    <updated>2022-02-06T16:04:53.689Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;git-branch-reset의-원리&quot;&gt;&lt;a href=&quot;#git-branch-reset의-원리&quot; class=&quot;headerlink&quot; title=&quot;git branch, reset의 원리&quot;&gt;&lt;/a&gt;git branch, reset의 원리&lt;/h1&gt;&lt;h1 id=&quot;git-branch의-원리&quot;&gt;&lt;a href=&quot;#git-branch의-원리&quot; class=&quot;headerlink&quot; title=&quot;git branch의 원리&quot;&gt;&lt;/a&gt;git branch의 원리&lt;/h1&gt;&lt;br/&gt;

&lt;h2 id=&quot;HEAD-파일&quot;&gt;&lt;a href=&quot;#HEAD-파일&quot; class=&quot;headerlink&quot; title=&quot;HEAD 파일&quot;&gt;&lt;/a&gt;HEAD 파일&lt;/h2&gt;&lt;p&gt;처음 git init 명령어를 실행할 경우 HEAD 파일이 생겨.&lt;/p&gt;
&lt;p&gt;.git 디렉토리 내부에 생성된 것을 확인할 수 있어.&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://devk0ng.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://devk0ng.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git branch와 merge의 기초</title>
    <link href="https://devk0ng.github.io/2022/01/25/git_branch_merge/"/>
    <id>https://devk0ng.github.io/2022/01/25/git_branch_merge/</id>
    <published>2022-01-24T16:57:02.703Z</published>
    <updated>2022-01-24T17:02:17.875Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;브랜치-Branch-란&quot;&gt;&lt;a href=&quot;#브랜치-Branch-란&quot; class=&quot;headerlink&quot; title=&quot;브랜치(Branch)란?&quot;&gt;&lt;/a&gt;브랜치(Branch)란?&lt;/h1&gt;&lt;p&gt;개발을 진행하다보면 현재 개발하는 코드를 복사하여 독립적인 개발(추가, 변경)을 진행해야하는 경우가 있지!&lt;/p&gt;
&lt;p&gt;이때 사용하는 것이 브랜치야!!&lt;/p&gt;
&lt;p&gt;독립적인 개발을 지원하는 것이 브랜치라고 생각하면 좋을 것 같애!&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://devk0ng.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://devk0ng.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>진정한 rest란?</title>
    <link href="https://devk0ng.github.io/2022/01/23/real_rest/"/>
    <id>https://devk0ng.github.io/2022/01/23/real_rest/</id>
    <published>2022-01-22T18:59:11.040Z</published>
    <updated>2022-01-25T17:04:53.384Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;진정한-REST란&quot;&gt;&lt;a href=&quot;#진정한-REST란&quot; class=&quot;headerlink&quot; title=&quot;진정한 REST란?&quot;&gt;&lt;/a&gt;진정한 REST란?&lt;/h1&gt;&lt;h1 id=&quot;REST란&quot;&gt;&lt;a href=&quot;#REST란&quot; class=&quot;headerlink&quot; title=&quot;REST란?&quot;&gt;&lt;/a&gt;REST란?&lt;/h1&gt;&lt;p&gt;Representational State Transfer의 줄임말로 Roy T. Fielding에 의해 만들어진 개념이다!&lt;/p&gt;
&lt;p&gt;이는 분산 하이퍼 미디어 시스템을(웹) 위한 아키텍쳐 스타일이고 제약조건의 집합이라고 볼 수 있어!!&lt;/p&gt;
&lt;p&gt;즉 rest를 만족하기 위한 조건들이 존재하고 이를 만족하였을 때 rest 구조를 따른다라고 이야기할 수 있는거지&lt;/p&gt;
&lt;p&gt;각 제약조건들의 핵심은 결국 interoperability를 만족하자! 라고 생각할 수 있어. 즉 상호운영성을 가지게 하자라는거지. &lt;/p&gt;
&lt;p&gt;조금 더 깊이 이해하기위해 발생하게 된 역사를 한번 보자!&lt;/p&gt;</summary>
    
    
    
    <category term="rest" scheme="https://devk0ng.github.io/categories/rest/"/>
    
    
    <category term="rest" scheme="https://devk0ng.github.io/tags/rest/"/>
    
  </entry>
  
  <entry>
    <title>Spring Web Mvc Interceptors란</title>
    <link href="https://devk0ng.github.io/2022/01/21/spring_interceptor/"/>
    <id>https://devk0ng.github.io/2022/01/21/spring_interceptor/</id>
    <published>2022-01-21T01:23:02.394Z</published>
    <updated>2022-01-21T01:53:45.292Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-Web-MVC-Interceptors&quot;&gt;&lt;a href=&quot;#Spring-Web-MVC-Interceptors&quot; class=&quot;headerlink&quot; title=&quot;[Spring Web MVC] Interceptors&quot;&gt;&lt;/a&gt;[Spring Web MVC] Interceptors&lt;/h1&gt;&lt;h1 id=&quot;인터셉터란&quot;&gt;&lt;a href=&quot;#인터셉터란&quot; class=&quot;headerlink&quot; title=&quot;인터셉터란?&quot;&gt;&lt;/a&gt;인터셉터란?&lt;/h1&gt;&lt;p&gt;아래 그림처럼 client의 요청이 controller로 가기 전에 중간에 요청을 가로채서 검사하는 모듈이야. 정확히는 컨트롤러의 핸들러를 호출하기 전과 후에 요청과 음답을 참조하거나 가공할 수 있는 녀석이라고 보면 될 거 같애&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="https://devk0ng.github.io/categories/spring/"/>
    
    
    <category term="spring" scheme="https://devk0ng.github.io/tags/spring/"/>
    
    <category term="spring wev mvc" scheme="https://devk0ng.github.io/tags/spring-wev-mvc/"/>
    
    <category term="interceptors" scheme="https://devk0ng.github.io/tags/interceptors/"/>
    
  </entry>
  
  <entry>
    <title>Inside Javascript 정리 - 2 (함수, 체이닝)</title>
    <link href="https://devk0ng.github.io/2022/01/20/inside_javascript2/"/>
    <id>https://devk0ng.github.io/2022/01/20/inside_javascript2/</id>
    <published>2022-01-20T04:45:03.037Z</published>
    <updated>2022-01-20T04:48:54.668Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;함수를-리턴하는-함수&quot;&gt;&lt;a href=&quot;#함수를-리턴하는-함수&quot; class=&quot;headerlink&quot; title=&quot;함수를 리턴하는 함수&quot;&gt;&lt;/a&gt;함수를 리턴하는 함수&lt;/h2&gt;&lt;p&gt;: 함수도 일급객체라고 했자나. 그래서 일반 값처럼 함수 자체를 리턴할 수도 있어. &lt;/p&gt;
&lt;p&gt;여기에서 오는 특징이 함수를 호출함과 동시에 다른 함수로 바꾸거나, 자기 자신을 재정의 하는 함수를 구현할수도 있게되는거야&lt;/p&gt;
&lt;br/&gt;


&lt;h2 id=&quot;arguments-객체&quot;&gt;&lt;a href=&quot;#arguments-객체&quot; class=&quot;headerlink&quot; title=&quot;arguments 객체&quot;&gt;&lt;/a&gt;arguments 객체&lt;/h2&gt;&lt;p&gt;: 자바스크립트에는 arguments라는 객체가 있어. 자바스크립트 함수에는 인자의 갯수를 함수의 정의에서 정해준 것 보다 더 많이 주던 더 적게 주던 에러가 발생하지 않아!&lt;/p&gt;
&lt;p&gt;그게 바로 arguments 객체 덕분이야. arguments 객체는 함수를 호출할 때 넘긴 인자들이 배열 형태로 저장된 객체를 의미해. 특이한 것은 정확히는 &lt;strong&gt;유사 배열 객체&lt;/strong&gt; 라는 점이지!&lt;/p&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://devk0ng.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://devk0ng.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Inside Javascript 정리 - 1 (데이터타입, 함수)</title>
    <link href="https://devk0ng.github.io/2022/01/20/inside_javascript1/"/>
    <id>https://devk0ng.github.io/2022/01/20/inside_javascript1/</id>
    <published>2022-01-20T04:35:35.617Z</published>
    <updated>2022-01-20T04:49:11.311Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Chapter-03-자바스크립트-데이터-타입과-연산자&quot;&gt;&lt;a href=&quot;#Chapter-03-자바스크립트-데이터-타입과-연산자&quot; class=&quot;headerlink&quot; title=&quot;Chapter 03 자바스크립트 데이터 타입과 연산자&quot;&gt;&lt;/a&gt;Chapter 03 자바스크립트 데이터 타입과 연산자&lt;/h1&gt;&lt;h2 id=&quot;자바스크립트-데이터-타입&quot;&gt;&lt;a href=&quot;#자바스크립트-데이터-타입&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트 데이터 타입&quot;&gt;&lt;/a&gt;자바스크립트 데이터 타입&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;기본 타입 - Number, String, Boolean, undefined, null&lt;/li&gt;
&lt;li&gt;참조 타입 - Object (Array, Function, 정규표현식)&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;


&lt;h2 id=&quot;자바스크립트-기본-타입&quot;&gt;&lt;a href=&quot;#자바스크립트-기본-타입&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트 기본 타입&quot;&gt;&lt;/a&gt;자바스크립트 기본 타입&lt;/h2&gt;&lt;p&gt;: 느슨한 타입 체크 언어로 변수를 선언할 때 타입을 미리 정하지 않고 , var이라는 한가지 키워드로만 변수를 선언해. 여기에는 어떤 데이터라도 저장하는 것이 가능한거지. &lt;/p&gt;
&lt;p&gt; 즉, 자바스크립트는 변수에 어떤 형태의 데이터를 저장하느냐에 따라 해당 변수의 타입이 결정되&lt;/p&gt;
&lt;br/&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://devk0ng.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://devk0ng.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>git의 원리에 대해 알아보자 (add, commit, status)</title>
    <link href="https://devk0ng.github.io/2022/01/20/git_add_commit_status/"/>
    <id>https://devk0ng.github.io/2022/01/20/git_add_commit_status/</id>
    <published>2022-01-19T16:35:05.007Z</published>
    <updated>2022-01-19T16:39:38.502Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;git의-원리&quot;&gt;&lt;a href=&quot;#git의-원리&quot; class=&quot;headerlink&quot; title=&quot;git의 원리&quot;&gt;&lt;/a&gt;git의 원리&lt;/h1&gt;&lt;p&gt;전체적인 흐름은 아래 그림과 같다. 여기서 add와 commit 그리고 status의 원리와 함께 위 흐름 중 일부를 간략하게 살펴보자&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://devk0ng.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://devk0ng.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>일급 컬렉션(First Class Collection)이란?</title>
    <link href="https://devk0ng.github.io/2022/01/18/first_class_collection/"/>
    <id>https://devk0ng.github.io/2022/01/18/first_class_collection/</id>
    <published>2022-01-17T17:03:51.505Z</published>
    <updated>2022-01-17T17:06:28.412Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;일급-컬렉션&quot;&gt;&lt;a href=&quot;#일급-컬렉션&quot; class=&quot;headerlink&quot; title=&quot;일급 컬렉션&quot;&gt;&lt;/a&gt;일급 컬렉션&lt;/h1&gt;&lt;h2 id=&quot;일급-컬렉션-정의&quot;&gt;&lt;a href=&quot;#일급-컬렉션-정의&quot; class=&quot;headerlink&quot; title=&quot;일급 컬렉션 정의&quot;&gt;&lt;/a&gt;일급 컬렉션 정의&lt;/h2&gt;&lt;p&gt; : collection을 wrapping 하면서, wrapping 한 collection 외에 다른 멤버 변수가 없는 상태를 일급 컬렉션이라 한데. 예를들자면&lt;/p&gt;</summary>
    
    
    
    <category term="clean code" scheme="https://devk0ng.github.io/categories/clean-code/"/>
    
    
    <category term="java" scheme="https://devk0ng.github.io/tags/java/"/>
    
    <category term="clean code" scheme="https://devk0ng.github.io/tags/clean-code/"/>
    
  </entry>
  
  <entry>
    <title>벌크성 수정쿼리 및 Entity Graph에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/11/01/spring_data_bulk_entitygraph/"/>
    <id>https://devk0ng.github.io/2021/11/01/spring_data_bulk_entitygraph/</id>
    <published>2021-10-31T17:10:24.088Z</published>
    <updated>2021-10-31T17:11:16.199Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;벌크성-수정쿼리&quot;&gt;&lt;a href=&quot;#벌크성-수정쿼리&quot; class=&quot;headerlink&quot; title=&quot;벌크성 수정쿼리&quot;&gt;&lt;/a&gt;벌크성 수정쿼리&lt;/h1&gt;&lt;p&gt;: 일반적으로 데이터의 update는 jpa의 dirty checking 기능을 활용한다! 그러나 여러 데이터들에 대해 일관된 업데이트 작업을 진행할 때에는 한번의 쿼리로 update 반영하는 것이 좋으며 이때, 벌크성 수정쿼리를 사용하면 되는 것이다!!&lt;/p&gt;
&lt;br/&gt;

&lt;h2 id=&quot;JPA-벌크성-수정쿼리&quot;&gt;&lt;a href=&quot;#JPA-벌크성-수정쿼리&quot; class=&quot;headerlink&quot; title=&quot;JPA 벌크성 수정쿼리&quot;&gt;&lt;/a&gt;JPA 벌크성 수정쿼리&lt;/h2&gt;&lt;p&gt;: Spring Data Jpa에서 어떻게 벌크성 수정쿼리를 제공하는지에 대해 보기전에 Jpa만으로 어떻게 사용할 수 있는지를 보자&lt;/p&gt;</summary>
    
    
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/categories/spring-data-jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/tags/spring-data-jpa/"/>
    
  </entry>
  
  <entry>
    <title>여러 탐색방법과 최소신장트리에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/10/26/searching_mst/"/>
    <id>https://devk0ng.github.io/2021/10/26/searching_mst/</id>
    <published>2021-10-25T17:40:56.780Z</published>
    <updated>2021-10-25T17:42:10.684Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;탐색&quot;&gt;&lt;a href=&quot;#탐색&quot; class=&quot;headerlink&quot; title=&quot;탐색&quot;&gt;&lt;/a&gt;탐색&lt;/h1&gt;&lt;h1 id=&quot;일반적인-탐색&quot;&gt;&lt;a href=&quot;#일반적인-탐색&quot; class=&quot;headerlink&quot; title=&quot;일반적인 탐색&quot;&gt;&lt;/a&gt;일반적인 탐색&lt;/h1&gt;&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;DFS&quot;&gt;&lt;a href=&quot;#DFS&quot; class=&quot;headerlink&quot; title=&quot;DFS&quot;&gt;&lt;/a&gt;DFS&lt;/h2&gt;&lt;br/&gt;

&lt;h3 id=&quot;개념&quot;&gt;&lt;a href=&quot;#개념&quot; class=&quot;headerlink&quot; title=&quot;개념&quot;&gt;&lt;/a&gt;개념&lt;/h3&gt;&lt;p&gt;: dfs는 깊이 우선 탁색(Depth First Search)로 루트 노드 (혹은 선택한 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완전하게 탐색하는 방법이야!!&lt;/p&gt;
&lt;p&gt;흔히 잘 알려진 미로를 탐색하는 문제로 예를 들어보자면, dfs로 미로탐색을 구현할 경우 한방향으로 갈 수 있을 때 까지 계속해서 들어갔다가 더이상 갈 곳이 없을 때 재귀함수가 풀리면서 이전 위치로 이동하게 되고 해당 위치에서 또 갈 수 있는 방향을 탐색해서 있다면 해당 방향으로 쭈욱 갈 수 있는 만큼 가고, 또 어디로도 못가는 상황이 되었다면 재귀가 풀리면서 이전 위치에서 다음 방향을 보고 이런식으로 진행이 되는거야. 정말 말 그대로 깊이 우선 탐색이지.&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="https://devk0ng.github.io/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://devk0ng.github.io/tags/algorithm/"/>
    
    <category term="search" scheme="https://devk0ng.github.io/tags/search/"/>
    
    <category term="mst" scheme="https://devk0ng.github.io/tags/mst/"/>
    
  </entry>
  
  <entry>
    <title>여러 자료구조에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/10/24/data_structure/"/>
    <id>https://devk0ng.github.io/2021/10/24/data_structure/</id>
    <published>2021-10-24T13:49:16.188Z</published>
    <updated>2021-10-24T15:55:31.133Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;선형자료구조&quot;&gt;&lt;a href=&quot;#선형자료구조&quot; class=&quot;headerlink&quot; title=&quot;선형자료구조&quot;&gt;&lt;/a&gt;선형자료구조&lt;/h1&gt;&lt;p&gt;: 선형자료구조란 하나의 자료뒤에 하나의 자료가 존재하고 이것들이 순차적으로 나열되어있는거지. 즉 자료들 간의 앞뒤 관계가 1:1의 관계라는거야&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;배열&quot;&gt;&lt;a href=&quot;#배열&quot; class=&quot;headerlink&quot; title=&quot;배열&quot;&gt;&lt;/a&gt;배열&lt;/h2&gt;&lt;p&gt;: &lt;strong&gt;여러 데이터를 하나의 이름으로 그룹핑&lt;/strong&gt;해서 관리하기 위한 자료구조야!! 배열은 &lt;strong&gt;정의와 동시에 길이를 지정하며 바꿀수가 없어&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;하지만 인덱스를 활용하여 빠르게 조회가 가능하다는 장점이 있어.&lt;/p&gt;
&lt;p&gt;물론 삭제의 경우도 인덱스를 접근하여 빠르게 지우는 것이 가능하나 여기서 지운다는 의미는 null, 혹은 0과 같은 ‘없음’을 의미하는 값을 넣는 것이고 결국은 &lt;strong&gt;메모리 공간을 차지&lt;/strong&gt;하게 되는 단점이 있다.&lt;/p&gt;</summary>
    
    
    
    <category term="data structure" scheme="https://devk0ng.github.io/categories/data-structure/"/>
    
    
    <category term="algorithm" scheme="https://devk0ng.github.io/tags/algorithm/"/>
    
    <category term="data structure" scheme="https://devk0ng.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>여러 정렬에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/10/23/sorting/"/>
    <id>https://devk0ng.github.io/2021/10/23/sorting/</id>
    <published>2021-10-23T13:23:45.610Z</published>
    <updated>2021-10-23T13:25:03.675Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;여러-종류의-정렬-알고리즘을-볼-때-비교-기준&quot;&gt;&lt;a href=&quot;#여러-종류의-정렬-알고리즘을-볼-때-비교-기준&quot; class=&quot;headerlink&quot; title=&quot;여러 종류의 정렬 알고리즘을 볼 때 비교 기준&quot;&gt;&lt;/a&gt;여러 종류의 정렬 알고리즘을 볼 때 비교 기준&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Stable vs Unstable : 만약 정렬하고자 하는 대상의 크기가 같은 경우, 대상들의 순서가 보장이 되는지(stable) 안되는지(unstable)&lt;/li&gt;
&lt;li&gt;In-place vs out-of-place : input에 대해 extra memory 없이 transform한다(in-place), 그렇지 않다 (out-of-place)&lt;/li&gt;
&lt;li&gt;시간복잡도, 공간복잡도&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="sorting" scheme="https://devk0ng.github.io/categories/sorting/"/>
    
    
    <category term="sorting" scheme="https://devk0ng.github.io/tags/sorting/"/>
    
    <category term="algorithm" scheme="https://devk0ng.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>스프링 데이터 JPA 페이징과 정렬에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/10/19/spring_data_jpa_paging_sort/"/>
    <id>https://devk0ng.github.io/2021/10/19/spring_data_jpa_paging_sort/</id>
    <published>2021-10-19T14:07:50.248Z</published>
    <updated>2021-10-19T14:12:02.161Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;반환-타입&quot;&gt;&lt;a href=&quot;#반환-타입&quot; class=&quot;headerlink&quot; title=&quot;반환 타입&quot;&gt;&lt;/a&gt;반환 타입&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Page(org.springframework.data.domain.Page) 형태 : 추가 count 쿼리 결과를 포함하는 페이징을 받을 수 있어&lt;/li&gt;
&lt;li&gt;Slice(org.springframework.data.domain.Slice) 형태 : 추가 count 쿼리 없이 다음 페이지만 확인 가능해 ( 내부적으로 limit + 1 로 가져와서 다음 데이터가 있는지 없는지를 체크하는거지)&lt;/li&gt;
&lt;li&gt;List : 추가 count 쿼리 없이 결과 반환&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/categories/spring-data-jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/tags/spring-data-jpa/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data Jpa Query Method에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/10/04/spring_data_jpa_query_method/"/>
    <id>https://devk0ng.github.io/2021/10/04/spring_data_jpa_query_method/</id>
    <published>2021-10-04T14:22:54.989Z</published>
    <updated>2021-10-04T14:25:05.707Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;쿼리-메소드-기능&quot;&gt;&lt;a href=&quot;#쿼리-메소드-기능&quot; class=&quot;headerlink&quot; title=&quot;쿼리 메소드 기능&quot;&gt;&lt;/a&gt;쿼리 메소드 기능&lt;/h1&gt;&lt;br/&gt;

&lt;h2 id=&quot;메소드-이름으로-쿼리-생성&quot;&gt;&lt;a href=&quot;#메소드-이름으로-쿼리-생성&quot; class=&quot;headerlink&quot; title=&quot;메소드 이름으로 쿼리 생성&quot;&gt;&lt;/a&gt;메소드 이름으로 쿼리 생성&lt;/h2&gt;&lt;p&gt;: 메소드 이름을 분석해서 JPQL 쿼리 실행을 시켜줘!!&lt;/p&gt;
&lt;br/&gt;

&lt;h3 id=&quot;스프링-데이터-jpa가-제공하는-쿼리-메소드-기능&quot;&gt;&lt;a href=&quot;#스프링-데이터-jpa가-제공하는-쿼리-메소드-기능&quot; class=&quot;headerlink&quot; title=&quot;스프링 데이터 jpa가 제공하는 쿼리 메소드 기능&quot;&gt;&lt;/a&gt;스프링 데이터 jpa가 제공하는 쿼리 메소드 기능&lt;/h3&gt;&lt;p&gt;(&lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#reference&quot;&gt;https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#reference&lt;/a&gt;)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;조회 : find…By, read…By, query…By, get…By (…에는 어떠한 것도 들어갈 수 있다 ex) findHelloBy)&lt;/li&gt;
&lt;li&gt;COUNT: count…By (반환타입 : long)&lt;/li&gt;
&lt;li&gt;EXISTS : exists…By (반환타입 : boolean)&lt;/li&gt;
&lt;li&gt;삭제 : delete…By, remove…By (반환타입 : long)&lt;/li&gt;
&lt;li&gt;DISTINCT : findDistinct, findMemberDistinctBy&lt;/li&gt;
&lt;li&gt;LIMIT : findFirst3, findFrist, findTop, findTop3 이런식으로&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/categories/spring-data-jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/tags/spring-data-jpa/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data Jpa를 시작하면서</title>
    <link href="https://devk0ng.github.io/2021/10/04/spring_data_jpa_start/"/>
    <id>https://devk0ng.github.io/2021/10/04/spring_data_jpa_start/</id>
    <published>2021-10-04T14:16:44.524Z</published>
    <updated>2021-10-04T14:25:16.535Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;스프링부트-라이브러리-구조&quot;&gt;&lt;a href=&quot;#스프링부트-라이브러리-구조&quot; class=&quot;headerlink&quot; title=&quot;스프링부트 라이브러리 구조&quot;&gt;&lt;/a&gt;스프링부트 라이브러리 구조&lt;/h1&gt;&lt;h3 id=&quot;Spring-boot-starter-Web&quot;&gt;&lt;a href=&quot;#Spring-boot-starter-Web&quot; class=&quot;headerlink&quot; title=&quot;Spring-boot-starter-Web&quot;&gt;&lt;/a&gt;Spring-boot-starter-Web&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;spring-boot-starter-tomcat&lt;/li&gt;
&lt;li&gt;spring-webmvc&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;

&lt;h3 id=&quot;spring-boot-starter-jdbc&quot;&gt;&lt;a href=&quot;#spring-boot-starter-jdbc&quot; class=&quot;headerlink&quot; title=&quot;spring-boot-starter-jdbc&quot;&gt;&lt;/a&gt;spring-boot-starter-jdbc&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;spring-boot-starter-aop&lt;/li&gt;
&lt;li&gt;spring-boot-starter-jdbc (HikariCp Connection Pool)&lt;/li&gt;
&lt;li&gt;spring-data-jpa&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/categories/spring-data-jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/tags/spring-data-jpa/"/>
    
  </entry>
  
  <entry>
    <title>객체지향쿼리언어 (JPQL) 심화 문법 (fetch join, named query, 벌크연산)</title>
    <link href="https://devk0ng.github.io/2021/08/22/jpa_jpql2/"/>
    <id>https://devk0ng.github.io/2021/08/22/jpa_jpql2/</id>
    <published>2021-08-22T12:51:30.484Z</published>
    <updated>2021-08-22T12:53:35.361Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;경로-표현식&quot;&gt;&lt;a href=&quot;#경로-표현식&quot; class=&quot;headerlink&quot; title=&quot;경로 표현식&quot;&gt;&lt;/a&gt;경로 표현식&lt;/h1&gt;&lt;p&gt;: .을 찍어 객체 그래프를 탐색하는 거야&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; m.username &lt;span class=&quot;operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;operator&quot;&gt;&amp;gt;&lt;/span&gt; 상태 필드&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Member&lt;/span&gt; m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt; m.team t &lt;span class=&quot;operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;operator&quot;&gt;&amp;gt;&lt;/span&gt; 단일 값 연관 필드&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt; m.orders o &lt;span class=&quot;operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;operator&quot;&gt;&amp;gt;&lt;/span&gt; 컬렉션 값 연관 필드&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; t.name &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;팀A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>객체지향쿼리언어 JPQL에 대해 알아보자!</title>
    <link href="https://devk0ng.github.io/2021/08/16/jpa_jpql/"/>
    <id>https://devk0ng.github.io/2021/08/16/jpa_jpql/</id>
    <published>2021-08-16T08:10:58.064Z</published>
    <updated>2021-08-16T08:12:14.434Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;객체지향쿼리언어-JPQL&quot;&gt;&lt;a href=&quot;#객체지향쿼리언어-JPQL&quot; class=&quot;headerlink&quot; title=&quot;객체지향쿼리언어 (JPQL)&quot;&gt;&lt;/a&gt;객체지향쿼리언어 (JPQL)&lt;/h1&gt;&lt;h1 id=&quot;JPA의-쿼리-방법-지원&quot;&gt;&lt;a href=&quot;#JPA의-쿼리-방법-지원&quot; class=&quot;headerlink&quot; title=&quot;JPA의 쿼리 방법 지원&quot;&gt;&lt;/a&gt;JPA의 쿼리 방법 지원&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JPQL&lt;/li&gt;
&lt;li&gt;JPA Criteria&lt;/li&gt;
&lt;li&gt;QueryDSL&lt;/li&gt;
&lt;li&gt;네이티브SQL (그냥 sql 쿼리 날리는 거)&lt;/li&gt;
&lt;li&gt;JDBC API 직접 사용, MyBatis, Spring JDBC Template&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 중에서도 JPQL 과 QueryDSL의 조합으로 사용하는 것이 좋아!!&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>Circuit Breaker와 MSA</title>
    <link href="https://devk0ng.github.io/2021/08/16/circuit_breaker/"/>
    <id>https://devk0ng.github.io/2021/08/16/circuit_breaker/</id>
    <published>2021-08-16T08:09:41.279Z</published>
    <updated>2021-08-16T08:10:53.933Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Circuit-breaker&quot;&gt;&lt;a href=&quot;#Circuit-breaker&quot; class=&quot;headerlink&quot; title=&quot;Circuit breaker&quot;&gt;&lt;/a&gt;Circuit breaker&lt;/h1&gt;&lt;h2 id=&quot;Circuit-Breaker는-어디에-쓰이는-놈인가&quot;&gt;&lt;a href=&quot;#Circuit-Breaker는-어디에-쓰이는-놈인가&quot; class=&quot;headerlink&quot; title=&quot;Circuit Breaker는 어디에 쓰이는 놈인가?&quot;&gt;&lt;/a&gt;Circuit Breaker는 어디에 쓰이는 놈인가?&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;circuit breaker&lt;/strong&gt;가 무엇을 하는 놈인가를 보기 전에 어디에 쓰는지를 먼저 보자&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MSA구조에서는 시스템을 여러개의 서비스 컴포넌트로 나누고 이러한 서비스 컴포넌트간에 호출하는 개념&lt;/strong&gt;을 가지고 있지.&lt;/p&gt;
&lt;p&gt;이러한 구조에서 잘 생각해보면 단점이 몇 가지 존재하는 데 그 중 하나가 &lt;strong&gt;장애전파가 일어날 수 있다는 점&lt;/strong&gt;이야!&lt;/p&gt;</summary>
    
    
    
    <category term="msa" scheme="https://devk0ng.github.io/categories/msa/"/>
    
    
    <category term="msa" scheme="https://devk0ng.github.io/tags/msa/"/>
    
    <category term="circuit breaker" scheme="https://devk0ng.github.io/tags/circuit-breaker/"/>
    
  </entry>
  
  <entry>
    <title>JPA 값 타입 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/08/13/jpa_valuetype/"/>
    <id>https://devk0ng.github.io/2021/08/13/jpa_valuetype/</id>
    <published>2021-08-12T16:44:15.229Z</published>
    <updated>2021-08-12T16:45:10.521Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;값타입&quot;&gt;&lt;a href=&quot;#값타입&quot; class=&quot;headerlink&quot; title=&quot;값타입&quot;&gt;&lt;/a&gt;값타입&lt;/h1&gt;&lt;br/&gt;

&lt;h1 id=&quot;JPA의-데이터-타입-분류&quot;&gt;&lt;a href=&quot;#JPA의-데이터-타입-분류&quot; class=&quot;headerlink&quot; title=&quot;JPA의 데이터 타입 분류&quot;&gt;&lt;/a&gt;JPA의 데이터 타입 분류&lt;/h1&gt;&lt;p&gt;JPA에는 크게 두개의 데이터 타입이 있어!! 바로 엔티티타입과 값타입이야.&lt;/p&gt;
&lt;br/&gt;

&lt;h2 id=&quot;엔티티-타입&quot;&gt;&lt;a href=&quot;#엔티티-타입&quot; class=&quot;headerlink&quot; title=&quot;엔티티 타입&quot;&gt;&lt;/a&gt;엔티티 타입&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;@Entity로 정의하는 객체!&lt;/li&gt;
&lt;li&gt;엔티티는 데이터가 변해도 식별자로 지속해서 추적이 가능해! 너무 당연한거지&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;

&lt;h2 id=&quot;값-타입&quot;&gt;&lt;a href=&quot;#값-타입&quot; class=&quot;headerlink&quot; title=&quot;값 타입&quot;&gt;&lt;/a&gt;값 타입&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체&lt;/li&gt;
&lt;li&gt;식별자가 없고 값만 있기에 변경시 추적이 불가능 해!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;갑 타입에 대해 알아보자!!&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA 영속성 전이(CASECADE)와 고아객체에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/08/11/jpa_cascade_orphan/"/>
    <id>https://devk0ng.github.io/2021/08/11/jpa_cascade_orphan/</id>
    <published>2021-08-10T17:28:54.001Z</published>
    <updated>2021-08-10T17:30:23.642Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;JPA-영속성-전이-CASECADE-와-고아객체&quot;&gt;&lt;a href=&quot;#JPA-영속성-전이-CASECADE-와-고아객체&quot; class=&quot;headerlink&quot; title=&quot;JPA 영속성 전이(CASECADE)와 고아객체&quot;&gt;&lt;/a&gt;JPA 영속성 전이(CASECADE)와 고아객체&lt;/h1&gt;&lt;h1 id=&quot;영속성-전이-CASECADE&quot;&gt;&lt;a href=&quot;#영속성-전이-CASECADE&quot; class=&quot;headerlink&quot; title=&quot;영속성 전이 (CASECADE)&quot;&gt;&lt;/a&gt;영속성 전이 (CASECADE)&lt;/h1&gt;&lt;p&gt;영속성 전이란 특정 &lt;strong&gt;엔티리를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때&lt;/strong&gt; 사용하면 되는 개념이야&lt;/p&gt;
&lt;p&gt;예를 들어 부모 엔티티를 persist할 때 자동으로 자식 엔티티도 함께 persist 시키고 싶을 때 말이지!&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA 프록시와 즉시로딩, 지연로딩에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/08/11/jpa_proxy_eager_lazy/"/>
    <id>https://devk0ng.github.io/2021/08/11/jpa_proxy_eager_lazy/</id>
    <published>2021-08-10T17:25:20.639Z</published>
    <updated>2021-08-10T17:30:49.229Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;프록시와-즉시로딩-지연로딩&quot;&gt;&lt;a href=&quot;#프록시와-즉시로딩-지연로딩&quot; class=&quot;headerlink&quot; title=&quot;프록시와 즉시로딩, 지연로딩&quot;&gt;&lt;/a&gt;프록시와 즉시로딩, 지연로딩&lt;/h1&gt;&lt;h1 id=&quot;프록시&quot;&gt;&lt;a href=&quot;#프록시&quot; class=&quot;headerlink&quot; title=&quot;프록시&quot;&gt;&lt;/a&gt;프록시&lt;/h1&gt;&lt;p&gt;지연로딩에 대해 이야기를 하기위해서는 프록시에 대해 먼저 알아야해!&lt;/p&gt;
&lt;p&gt;프록시가 무엇이냐??&lt;/p&gt;
&lt;p&gt;쉽게 말하면 &lt;strong&gt;가짜 엔티티&lt;/strong&gt;라고 생각할 수 있어&lt;/p&gt;
&lt;p&gt;EntityManger를 통해 프록시 객체를 조회하기 위해서는 em.getReference() 메소드를 이용할 수 있어!! 그러면 프록시를 가져와!!&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA 상속관계 매핑에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/08/09/jpa_inheritance_mapping/"/>
    <id>https://devk0ng.github.io/2021/08/09/jpa_inheritance_mapping/</id>
    <published>2021-08-08T16:23:36.862Z</published>
    <updated>2021-08-08T16:25:46.840Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;상속관계-매핑이란&quot;&gt;&lt;a href=&quot;#상속관계-매핑이란&quot; class=&quot;headerlink&quot; title=&quot;상속관계 매핑이란&quot;&gt;&lt;/a&gt;상속관계 매핑이란&lt;/h1&gt;&lt;p&gt;: 먼저 데이터 베이스는 원래는 상속 관계를 지원하지 않아!! But 슈퍼타입-서브타입이라는 모델링 기법이 존재하고 이녀석이 객체 상속과 비슷하게 생겼어!! 이를 이용해서 상속관계를 나타내보자!! 이렇게 된거지&lt;/p&gt;
&lt;p&gt;그래서 &lt;strong&gt;상속관계 매핑은 객체의 상속구조와 데이터베이스의 슈퍼타입-서브타입 관계를 매핑하는거야!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;여기에는 크게 3가지 전략이 있어&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;조인전략&lt;/li&gt;
&lt;li&gt;단일 테이블 전략&lt;/li&gt;
&lt;li&gt;구현 클래스마다 테이블 전략&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 3가지에 대해 알아볼거야. 참고로 어떤 전략을 쓰던 jpa에서는 상관없이 전부 매핑이 가능해.&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA 연관관계 매핑에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/08/02/jpa_relation_mapping/"/>
    <id>https://devk0ng.github.io/2021/08/02/jpa_relation_mapping/</id>
    <published>2021-08-01T16:47:18.961Z</published>
    <updated>2021-08-01T16:52:10.625Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;연관관계-용어정리와-간단한-설명&quot;&gt;&lt;a href=&quot;#연관관계-용어정리와-간단한-설명&quot; class=&quot;headerlink&quot; title=&quot;연관관계 용어정리와 간단한 설명&quot;&gt;&lt;/a&gt;연관관계 용어정리와 간단한 설명&lt;/h2&gt;&lt;p&gt;연관관계 매핑을 알아보기에 앞서 기본적인 용어를 정리하고 들어간당&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;방향 - 단방향, 양방향&lt;/li&gt;
&lt;li&gt;다중성 - 다대일, 일대다, 일대일, 다대다&lt;/li&gt;
&lt;li&gt;연관관계의 주인 - 양방향 관계에서는 연관관계 주인이라는 것을 설정해줘야해!! 중요!!&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;

&lt;h3 id=&quot;방향-별-사용방법&quot;&gt;&lt;a href=&quot;#방향-별-사용방법&quot; class=&quot;headerlink&quot; title=&quot;방향 별 사용방법&quot;&gt;&lt;/a&gt;방향 별 사용방법&lt;/h3&gt;&lt;p&gt;단뱡향은 그냥 @OneToMany, @ManyToOne … 등 관계를 나타내는 어노테이션과 @JoinColumn(name = “blabla”) 를 통해 외래키를 매핑해주고 그냥 사용하면 돼!!&lt;/p&gt;
&lt;p&gt;but, &lt;strong&gt;양방향의 경우에는 두 관계중 연관관계의 주인을 결정해 줘야해!!&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA와 기본 키 매핑에 관하여</title>
    <link href="https://devk0ng.github.io/2021/07/30/jpa_key_mapping/"/>
    <id>https://devk0ng.github.io/2021/07/30/jpa_key_mapping/</id>
    <published>2021-07-29T16:53:26.359Z</published>
    <updated>2021-07-29T16:55:31.090Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;JPA-기본-키-매핑&quot;&gt;&lt;a href=&quot;#JPA-기본-키-매핑&quot; class=&quot;headerlink&quot; title=&quot;JPA 기본 키 매핑&quot;&gt;&lt;/a&gt;JPA 기본 키 매핑&lt;/h1&gt;&lt;p&gt;기본키를 매핑하려면 @Id 어노테이션을 필드위에 선언해주면 돼!!&lt;/p&gt;
&lt;p&gt;추가적으로 @GeneratedValue라는 어노테이션과 함께 많이 사용하는데 이 어노테이션에 대해 알아보자!!&lt;/p&gt;
&lt;p&gt;먼저 기본 키 매핑 방법에는 두가지가 있어!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;직접할당과 자동생성&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>자주 사용되는 lombok, 주의 사항</title>
    <link href="https://devk0ng.github.io/2021/07/30/lombok/"/>
    <id>https://devk0ng.github.io/2021/07/30/lombok/</id>
    <published>2021-07-29T16:40:55.964Z</published>
    <updated>2021-07-29T16:42:33.478Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Getter-Setter&quot;&gt;&lt;a href=&quot;#Getter-Setter&quot; class=&quot;headerlink&quot; title=&quot;@Getter, @Setter&quot;&gt;&lt;/a&gt;@Getter, @Setter&lt;/h2&gt;&lt;p&gt;: 말그대로 getter, setter method를 생성해주는 놈이야!&lt;/p&gt;
&lt;p&gt;AccessLevel을 명시해줌으로써 접근제한자를 지정 해 줄 수 있어.&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="https://devk0ng.github.io/categories/spring/"/>
    
    
    <category term="spring" scheme="https://devk0ng.github.io/tags/spring/"/>
    
    <category term="lombok" scheme="https://devk0ng.github.io/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>앤티티 매핑(매핑 어노테이션 정리) 정리</title>
    <link href="https://devk0ng.github.io/2021/07/27/entity-mapping/"/>
    <id>https://devk0ng.github.io/2021/07/27/entity-mapping/</id>
    <published>2021-07-26T15:53:59.630Z</published>
    <updated>2021-07-28T15:53:22.666Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;객체와-테이블-매핑-관련-어노테이션&quot;&gt;&lt;a href=&quot;#객체와-테이블-매핑-관련-어노테이션&quot; class=&quot;headerlink&quot; title=&quot;객체와 테이블 매핑 관련 어노테이션&quot;&gt;&lt;/a&gt;객체와 테이블 매핑 관련 어노테이션&lt;/h1&gt;&lt;p&gt;객체와 테이블 매핑에 대해 먼저 알아보자!&lt;/p&gt;
&lt;h2 id=&quot;Entity&quot;&gt;&lt;a href=&quot;#Entity&quot; class=&quot;headerlink&quot; title=&quot;@Entity&quot;&gt;&lt;/a&gt;@Entity&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;@Entity가 붙은 클래스는 jpa가 관리하는 녀석이고 엔티티라고 한다.&lt;/li&gt;
&lt;li&gt;JPA를 사용해서 테이플과 매핑할&lt;/li&gt;
&lt;li&gt;name이라는 속성을 지정해 줄 수 있는데 이는 jpa에서 사용할 엔티티 이름이구 기본값은 클래스 이름을 그대로 사용해! (왠만하면 기본값을 사용)&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="entity" scheme="https://devk0ng.github.io/tags/entity/"/>
    
  </entry>
  
  <entry>
    <title>Saga Pattern이란?(Orchestration and Choreography)</title>
    <link href="https://devk0ng.github.io/2021/07/27/saga_pattern/"/>
    <id>https://devk0ng.github.io/2021/07/27/saga_pattern/</id>
    <published>2021-07-26T15:53:57.552Z</published>
    <updated>2021-07-28T13:48:09.414Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;2-Phase-Commit&quot;&gt;&lt;a href=&quot;#2-Phase-Commit&quot; class=&quot;headerlink&quot; title=&quot;2-Phase Commit&quot;&gt;&lt;/a&gt;2-Phase Commit&lt;/h1&gt;&lt;p&gt;우선 먼저 MSA구조 이전에는 분산 데이터베이스에 대해 어떻게 트랜잭션을 만족시켰는지 보자!!&lt;/p&gt;
&lt;p&gt;이때는 &lt;strong&gt;2-Phase Commit&lt;/strong&gt;이라는 방법을 사용했어!!&lt;/p&gt;
&lt;p&gt;참고로 사용하는 데이터베이스가 분산 트랜젝션을 지원해야 사용할 수 있는 방법이야!! (같은 종류의 데이터베이스이어야 하기에 MSA구조에는 적합하지 않겠지)&lt;/p&gt;</summary>
    
    
    
    <category term="Saga" scheme="https://devk0ng.github.io/categories/Saga/"/>
    
    
    <category term="msa" scheme="https://devk0ng.github.io/tags/msa/"/>
    
    <category term="saga pattern" scheme="https://devk0ng.github.io/tags/saga-pattern/"/>
    
    <category term="saga" scheme="https://devk0ng.github.io/tags/saga/"/>
    
    <category term="2pc" scheme="https://devk0ng.github.io/tags/2pc/"/>
    
    <category term="2 phase commit" scheme="https://devk0ng.github.io/tags/2-phase-commit/"/>
    
  </entry>
  
  <entry>
    <title>MSA와 API GATEWAY의 개념</title>
    <link href="https://devk0ng.github.io/2021/07/27/msa-and-api_gateway/"/>
    <id>https://devk0ng.github.io/2021/07/27/msa-and-api_gateway/</id>
    <published>2021-07-26T15:53:49.838Z</published>
    <updated>2021-07-28T13:29:59.041Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Monolitich-Architecture&quot;&gt;&lt;a href=&quot;#Monolitich-Architecture&quot; class=&quot;headerlink&quot; title=&quot;Monolitich Architecture&quot;&gt;&lt;/a&gt;Monolitich Architecture&lt;/h1&gt;&lt;p&gt;먼저 MSA를 알기위해서는 모노리틱 아키텍쳐를 알아야해!!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;모노티릭 아키텍쳐란?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;기존의 전통적인 웹 시스템 개발 스타일이고 하나의 어플리케이션 내에 모든 로직들이 모두~ 들어가있는 그런 통짜구조라고 생각하면 돼.&lt;/p&gt;</summary>
    
    
    
    <category term="msa" scheme="https://devk0ng.github.io/categories/msa/"/>
    
    
    <category term="msa" scheme="https://devk0ng.github.io/tags/msa/"/>
    
    <category term="gateway" scheme="https://devk0ng.github.io/tags/gateway/"/>
    
    <category term="api gateway" scheme="https://devk0ng.github.io/tags/api-gateway/"/>
    
  </entry>
  
  <entry>
    <title>다형성과 SOLID, 그리고 Spring</title>
    <link href="https://devk0ng.github.io/2021/07/27/polymorphism_and_solid_and_spring/"/>
    <id>https://devk0ng.github.io/2021/07/27/polymorphism_and_solid_and_spring/</id>
    <published>2021-07-26T15:49:09.663Z</published>
    <updated>2021-07-29T16:34:38.683Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;다형성-Polymorphism&quot;&gt;&lt;a href=&quot;#다형성-Polymorphism&quot; class=&quot;headerlink&quot; title=&quot;다형성(Polymorphism)&quot;&gt;&lt;/a&gt;다형성(Polymorphism)&lt;/h1&gt;&lt;br/&gt;

&lt;p&gt;&lt;strong&gt;다형성&lt;/strong&gt;은 객체지향의 특징 중 하나이다!&lt;br&gt;쉽게 말해 하나의 객체가 여러가지 타입을 가질 수 있는 것을 의미해.&lt;/p&gt;
&lt;p&gt;딱 위의 개념을 자바 문법에 대입해 보면 한가지 떠오르는 놈이 있지! 바로~ 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조하는 것!! 또는 인터페이스로 그 구현체를 참조하는 것!!&lt;/p&gt;
&lt;p&gt;실세계와 객체 지향이 완전히 1:1로 매칭이 되는 것은 아니나 역할과 구현을 분리해서 생각하면 실세계를 통해 다형성을 이해하기 수월해!!&lt;/p&gt;
&lt;p&gt;한가지 예를 들어볼게!!&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="https://devk0ng.github.io/categories/spring/"/>
    
    
    <category term="polymorphism" scheme="https://devk0ng.github.io/tags/polymorphism/"/>
    
    <category term="solid" scheme="https://devk0ng.github.io/tags/solid/"/>
    
    <category term="spring" scheme="https://devk0ng.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>API Composition vs CQRS Pattern</title>
    <link href="https://devk0ng.github.io/2021/07/27/api_composition_and_cqrs/"/>
    <id>https://devk0ng.github.io/2021/07/27/api_composition_and_cqrs/</id>
    <published>2021-07-26T15:49:07.495Z</published>
    <updated>2021-07-27T16:07:45.103Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;API-Composition과-CQRS-등장배경&quot;&gt;&lt;a href=&quot;#API-Composition과-CQRS-등장배경&quot; class=&quot;headerlink&quot; title=&quot;API Composition과 CQRS 등장배경&quot;&gt;&lt;/a&gt;API Composition과 CQRS 등장배경&lt;/h1&gt;&lt;p&gt;마이크로서비스로 전체 구성을 하였다고 가정을 해보자!&lt;br/&gt;특정 서비스를 제공하는 녀석을 A라고 가정해본닷. 그리고 A로 전달된 클라이언트의 request를 처리하기 위해서는 A친구는 다른 마이크로서비스 B,C,D에서 제공하는 정보를 조합해서 클라이언트에게 최종적인 결과를 주어야한닷&lt;/p&gt;
&lt;p&gt;이때, 이 상황에서 사용할 수 있는 방법이 2가지 존재해!!&lt;/p&gt;
&lt;p&gt;바로~ API Composition과 CQRS야!!&lt;/p&gt;</summary>
    
    
    
    <category term="msa" scheme="https://devk0ng.github.io/categories/msa/"/>
    
    
    <category term="msa" scheme="https://devk0ng.github.io/tags/msa/"/>
    
    <category term="cqrs" scheme="https://devk0ng.github.io/tags/cqrs/"/>
    
    <category term="api" scheme="https://devk0ng.github.io/tags/api/"/>
    
    <category term="composition" scheme="https://devk0ng.github.io/tags/composition/"/>
    
    <category term="API_Composition" scheme="https://devk0ng.github.io/tags/API-Composition/"/>
    
  </entry>
  
  <entry>
    <title>CQRS 패턴이란?</title>
    <link href="https://devk0ng.github.io/2021/07/27/cqrs/"/>
    <id>https://devk0ng.github.io/2021/07/27/cqrs/</id>
    <published>2021-07-26T15:49:05.385Z</published>
    <updated>2021-07-28T14:23:38.120Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;CQRS란&quot;&gt;&lt;a href=&quot;#CQRS란&quot; class=&quot;headerlink&quot; title=&quot;CQRS란&quot;&gt;&lt;/a&gt;CQRS란&lt;/h1&gt;&lt;p&gt;CQRS는 &lt;strong&gt;Command Query Responsibility Segregation&lt;/strong&gt; 의 약자이다!&lt;br&gt;명령 조회 책임 분리 패턴이라는 의미 그대로 받아들이면 제일 좋을 것 같다!!&lt;br/&gt;잠깐, 여기서 Command(명령)은 데이터의 변화를 주는 입력, 수정, 삭제 관련 작업들이라 볼 수 있고 Query는 조회와 관련된 작업이라 보면 된다! 즉 시스템 상태를 변경하냐 마냐의 유무라고 생각하면 될 것 같넹&lt;/p&gt;</summary>
    
    
    
    <category term="msa" scheme="https://devk0ng.github.io/categories/msa/"/>
    
    
    <category term="msa" scheme="https://devk0ng.github.io/tags/msa/"/>
    
    <category term="cqrs" scheme="https://devk0ng.github.io/tags/cqrs/"/>
    
  </entry>
  
  <entry>
    <title>영속성 컨택스트(Persistence Context)란?</title>
    <link href="https://devk0ng.github.io/2021/07/27/persistence_context/"/>
    <id>https://devk0ng.github.io/2021/07/27/persistence_context/</id>
    <published>2021-07-26T15:49:01.319Z</published>
    <updated>2021-07-28T13:44:49.978Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;영속성-컨텍스트란&quot;&gt;&lt;a href=&quot;#영속성-컨텍스트란&quot; class=&quot;headerlink&quot; title=&quot;영속성 컨텍스트란&quot;&gt;&lt;/a&gt;영속성 컨텍스트란&lt;/h1&gt;&lt;p&gt;JPA에서 가장 중요한 것을 두가지 뽑으라면 객체와 관계형 데이터베이스의 매핑과 &lt;strong&gt;영속성 컨텍스트&lt;/strong&gt;를 뽑을 수 있을 것 같다!!&lt;/p&gt;
&lt;p&gt;EntityManager는 요청마다 생겨서 database에 대한 connection을 얻은 후 database에 필요한 작업을 한다!!&lt;/p&gt;
&lt;p&gt;이때 EntityManager 객체 em에 대해 em.persist()를 하면 database에 insert가 된다고 생각을 하고있으나&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
    <category term="persistence" scheme="https://devk0ng.github.io/tags/persistence/"/>
    
    <category term="persistence context" scheme="https://devk0ng.github.io/tags/persistence-context/"/>
    
  </entry>
  
  <entry>
    <title>JPA는 왜 등장했는가?</title>
    <link href="https://devk0ng.github.io/2021/07/27/why_jpa/"/>
    <id>https://devk0ng.github.io/2021/07/27/why_jpa/</id>
    <published>2021-07-26T15:48:58.207Z</published>
    <updated>2021-07-28T13:38:35.145Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;JPA-등장배경&quot;&gt;&lt;a href=&quot;#JPA-등장배경&quot; class=&quot;headerlink&quot; title=&quot;JPA 등장배경&quot;&gt;&lt;/a&gt;JPA 등장배경&lt;/h1&gt;&lt;p&gt;JPA가 등장하게 된 배경이 무엇일까??&lt;br/&gt;객체를 관계형 데이터베이스에 저장하기 위해서는 중간에서 변환해주는 작업이 필요해!!&lt;/p&gt;
&lt;p&gt;WHY?&lt;/p&gt;
&lt;p&gt;객체와 관계형 데이터베이스간에는 해소하지 못하는 차이점이 존재해!!&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA의 사용방법에 대해</title>
    <link href="https://devk0ng.github.io/2021/07/27/how_to_use_jpa/"/>
    <id>https://devk0ng.github.io/2021/07/27/how_to_use_jpa/</id>
    <published>2021-07-26T15:35:34.072Z</published>
    <updated>2021-07-27T16:21:15.253Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;데이터베이스-방언&quot;&gt;&lt;a href=&quot;#데이터베이스-방언&quot; class=&quot;headerlink&quot; title=&quot;데이터베이스 방언&quot;&gt;&lt;/a&gt;데이터베이스 방언&lt;/h1&gt;&lt;p&gt;jpa 사용법을 이야기하기에 앞서 좋은 점 하나를 끄적이고 시작하겠다 이말이야~&lt;/p&gt;
&lt;p&gt;데이터베이스에는 방언이라는 놈이 존재해!!&lt;/p&gt;
&lt;p&gt;그게 뭐신디!? 각각의 데이터베이스가 제공하는 SQL문법과 함수는 조금씩 달라!! (가변문자를 보면 MYSQL : VARCHAR, ORACLE : VARCHAR2)&lt;/p&gt;
&lt;p&gt;이처럼 &lt;strong&gt;SQL 표준을 지키지 않은 특정 데이터베이스만의 고유한 기능을 방언&lt;/strong&gt;이라고 하는데 &lt;strong&gt;JPA는 이에 종속적이지 않아!!&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
</feed>
