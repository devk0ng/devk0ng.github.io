<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>devk0ng&#39;s blog</title>
  
  <subtitle>Slow and Steady! This is my development study note</subtitle>
  <link href="https://devk0ng.github.io/atom.xml" rel="self"/>
  
  <link href="https://devk0ng.github.io/"/>
  <updated>2021-10-19T14:12:02.161Z</updated>
  <id>https://devk0ng.github.io/</id>
  
  <author>
    <name>Sungbin Hong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>스프링 데이터 JPA 페이징과 정렬에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/10/19/spring_data_jpa_paging_sort/"/>
    <id>https://devk0ng.github.io/2021/10/19/spring_data_jpa_paging_sort/</id>
    <published>2021-10-19T14:07:50.248Z</published>
    <updated>2021-10-19T14:12:02.161Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;반환-타입&quot;&gt;&lt;a href=&quot;#반환-타입&quot; class=&quot;headerlink&quot; title=&quot;반환 타입&quot;&gt;&lt;/a&gt;반환 타입&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Page(org.springframework.data.domain.Page) 형태 : 추가 count 쿼리 결과를 포함하는 페이징을 받을 수 있어&lt;/li&gt;
&lt;li&gt;Slice(org.springframework.data.domain.Slice) 형태 : 추가 count 쿼리 없이 다음 페이지만 확인 가능해 ( 내부적으로 limit + 1 로 가져와서 다음 데이터가 있는지 없는지를 체크하는거지)&lt;/li&gt;
&lt;li&gt;List : 추가 count 쿼리 없이 결과 반환&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/categories/spring-data-jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/tags/spring-data-jpa/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data Jpa Query Method에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/10/04/spring_data_jpa_query_method/"/>
    <id>https://devk0ng.github.io/2021/10/04/spring_data_jpa_query_method/</id>
    <published>2021-10-04T14:22:54.989Z</published>
    <updated>2021-10-04T14:25:05.707Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;쿼리-메소드-기능&quot;&gt;&lt;a href=&quot;#쿼리-메소드-기능&quot; class=&quot;headerlink&quot; title=&quot;쿼리 메소드 기능&quot;&gt;&lt;/a&gt;쿼리 메소드 기능&lt;/h1&gt;&lt;br/&gt;

&lt;h2 id=&quot;메소드-이름으로-쿼리-생성&quot;&gt;&lt;a href=&quot;#메소드-이름으로-쿼리-생성&quot; class=&quot;headerlink&quot; title=&quot;메소드 이름으로 쿼리 생성&quot;&gt;&lt;/a&gt;메소드 이름으로 쿼리 생성&lt;/h2&gt;&lt;p&gt;: 메소드 이름을 분석해서 JPQL 쿼리 실행을 시켜줘!!&lt;/p&gt;
&lt;br/&gt;

&lt;h3 id=&quot;스프링-데이터-jpa가-제공하는-쿼리-메소드-기능&quot;&gt;&lt;a href=&quot;#스프링-데이터-jpa가-제공하는-쿼리-메소드-기능&quot; class=&quot;headerlink&quot; title=&quot;스프링 데이터 jpa가 제공하는 쿼리 메소드 기능&quot;&gt;&lt;/a&gt;스프링 데이터 jpa가 제공하는 쿼리 메소드 기능&lt;/h3&gt;&lt;p&gt;(&lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#reference&quot;&gt;https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#reference&lt;/a&gt;)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;조회 : find…By, read…By, query…By, get…By (…에는 어떠한 것도 들어갈 수 있다 ex) findHelloBy)&lt;/li&gt;
&lt;li&gt;COUNT: count…By (반환타입 : long)&lt;/li&gt;
&lt;li&gt;EXISTS : exists…By (반환타입 : boolean)&lt;/li&gt;
&lt;li&gt;삭제 : delete…By, remove…By (반환타입 : long)&lt;/li&gt;
&lt;li&gt;DISTINCT : findDistinct, findMemberDistinctBy&lt;/li&gt;
&lt;li&gt;LIMIT : findFirst3, findFrist, findTop, findTop3 이런식으로&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/categories/spring-data-jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/tags/spring-data-jpa/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data Jpa를 시작하면서</title>
    <link href="https://devk0ng.github.io/2021/10/04/spring_data_jpa_start/"/>
    <id>https://devk0ng.github.io/2021/10/04/spring_data_jpa_start/</id>
    <published>2021-10-04T14:16:44.524Z</published>
    <updated>2021-10-04T14:25:16.535Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;스프링부트-라이브러리-구조&quot;&gt;&lt;a href=&quot;#스프링부트-라이브러리-구조&quot; class=&quot;headerlink&quot; title=&quot;스프링부트 라이브러리 구조&quot;&gt;&lt;/a&gt;스프링부트 라이브러리 구조&lt;/h1&gt;&lt;h3 id=&quot;Spring-boot-starter-Web&quot;&gt;&lt;a href=&quot;#Spring-boot-starter-Web&quot; class=&quot;headerlink&quot; title=&quot;Spring-boot-starter-Web&quot;&gt;&lt;/a&gt;Spring-boot-starter-Web&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;spring-boot-starter-tomcat&lt;/li&gt;
&lt;li&gt;spring-webmvc&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;

&lt;h3 id=&quot;spring-boot-starter-jdbc&quot;&gt;&lt;a href=&quot;#spring-boot-starter-jdbc&quot; class=&quot;headerlink&quot; title=&quot;spring-boot-starter-jdbc&quot;&gt;&lt;/a&gt;spring-boot-starter-jdbc&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;spring-boot-starter-aop&lt;/li&gt;
&lt;li&gt;spring-boot-starter-jdbc (HikariCp Connection Pool)&lt;/li&gt;
&lt;li&gt;spring-data-jpa&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/categories/spring-data-jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
    <category term="spring data jpa" scheme="https://devk0ng.github.io/tags/spring-data-jpa/"/>
    
  </entry>
  
  <entry>
    <title>객체지향쿼리언어 (JPQL) 심화 문법 (fetch join, named query, 벌크연산)</title>
    <link href="https://devk0ng.github.io/2021/08/22/jpa_jpql2/"/>
    <id>https://devk0ng.github.io/2021/08/22/jpa_jpql2/</id>
    <published>2021-08-22T12:51:30.484Z</published>
    <updated>2021-08-22T12:53:35.361Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;경로-표현식&quot;&gt;&lt;a href=&quot;#경로-표현식&quot; class=&quot;headerlink&quot; title=&quot;경로 표현식&quot;&gt;&lt;/a&gt;경로 표현식&lt;/h1&gt;&lt;p&gt;: .을 찍어 객체 그래프를 탐색하는 거야&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; m.username &lt;span class=&quot;operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;operator&quot;&gt;&amp;gt;&lt;/span&gt; 상태 필드&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Member&lt;/span&gt; m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt; m.team t &lt;span class=&quot;operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;operator&quot;&gt;&amp;gt;&lt;/span&gt; 단일 값 연관 필드&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt; m.orders o &lt;span class=&quot;operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;operator&quot;&gt;&amp;gt;&lt;/span&gt; 컬렉션 값 연관 필드&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; t.name &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;팀A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>객체지향쿼리언어 JPQL에 대해 알아보자!</title>
    <link href="https://devk0ng.github.io/2021/08/16/jpa_jpql/"/>
    <id>https://devk0ng.github.io/2021/08/16/jpa_jpql/</id>
    <published>2021-08-16T08:10:58.064Z</published>
    <updated>2021-08-16T08:12:14.434Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;객체지향쿼리언어-JPQL&quot;&gt;&lt;a href=&quot;#객체지향쿼리언어-JPQL&quot; class=&quot;headerlink&quot; title=&quot;객체지향쿼리언어 (JPQL)&quot;&gt;&lt;/a&gt;객체지향쿼리언어 (JPQL)&lt;/h1&gt;&lt;h1 id=&quot;JPA의-쿼리-방법-지원&quot;&gt;&lt;a href=&quot;#JPA의-쿼리-방법-지원&quot; class=&quot;headerlink&quot; title=&quot;JPA의 쿼리 방법 지원&quot;&gt;&lt;/a&gt;JPA의 쿼리 방법 지원&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JPQL&lt;/li&gt;
&lt;li&gt;JPA Criteria&lt;/li&gt;
&lt;li&gt;QueryDSL&lt;/li&gt;
&lt;li&gt;네이티브SQL (그냥 sql 쿼리 날리는 거)&lt;/li&gt;
&lt;li&gt;JDBC API 직접 사용, MyBatis, Spring JDBC Template&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 중에서도 JPQL 과 QueryDSL의 조합으로 사용하는 것이 좋아!!&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>Circuit Breaker와 MSA</title>
    <link href="https://devk0ng.github.io/2021/08/16/circuit_breaker/"/>
    <id>https://devk0ng.github.io/2021/08/16/circuit_breaker/</id>
    <published>2021-08-16T08:09:41.279Z</published>
    <updated>2021-08-16T08:10:53.933Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Circuit-breaker&quot;&gt;&lt;a href=&quot;#Circuit-breaker&quot; class=&quot;headerlink&quot; title=&quot;Circuit breaker&quot;&gt;&lt;/a&gt;Circuit breaker&lt;/h1&gt;&lt;h2 id=&quot;Circuit-Breaker는-어디에-쓰이는-놈인가&quot;&gt;&lt;a href=&quot;#Circuit-Breaker는-어디에-쓰이는-놈인가&quot; class=&quot;headerlink&quot; title=&quot;Circuit Breaker는 어디에 쓰이는 놈인가?&quot;&gt;&lt;/a&gt;Circuit Breaker는 어디에 쓰이는 놈인가?&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;circuit breaker&lt;/strong&gt;가 무엇을 하는 놈인가를 보기 전에 어디에 쓰는지를 먼저 보자&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MSA구조에서는 시스템을 여러개의 서비스 컴포넌트로 나누고 이러한 서비스 컴포넌트간에 호출하는 개념&lt;/strong&gt;을 가지고 있지.&lt;/p&gt;
&lt;p&gt;이러한 구조에서 잘 생각해보면 단점이 몇 가지 존재하는 데 그 중 하나가 &lt;strong&gt;장애전파가 일어날 수 있다는 점&lt;/strong&gt;이야!&lt;/p&gt;</summary>
    
    
    
    <category term="msa" scheme="https://devk0ng.github.io/categories/msa/"/>
    
    
    <category term="msa" scheme="https://devk0ng.github.io/tags/msa/"/>
    
    <category term="circuit breaker" scheme="https://devk0ng.github.io/tags/circuit-breaker/"/>
    
  </entry>
  
  <entry>
    <title>JPA 값 타입 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/08/13/jpa_valuetype/"/>
    <id>https://devk0ng.github.io/2021/08/13/jpa_valuetype/</id>
    <published>2021-08-12T16:44:15.229Z</published>
    <updated>2021-08-12T16:45:10.521Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;값타입&quot;&gt;&lt;a href=&quot;#값타입&quot; class=&quot;headerlink&quot; title=&quot;값타입&quot;&gt;&lt;/a&gt;값타입&lt;/h1&gt;&lt;br/&gt;

&lt;h1 id=&quot;JPA의-데이터-타입-분류&quot;&gt;&lt;a href=&quot;#JPA의-데이터-타입-분류&quot; class=&quot;headerlink&quot; title=&quot;JPA의 데이터 타입 분류&quot;&gt;&lt;/a&gt;JPA의 데이터 타입 분류&lt;/h1&gt;&lt;p&gt;JPA에는 크게 두개의 데이터 타입이 있어!! 바로 엔티티타입과 값타입이야.&lt;/p&gt;
&lt;br/&gt;

&lt;h2 id=&quot;엔티티-타입&quot;&gt;&lt;a href=&quot;#엔티티-타입&quot; class=&quot;headerlink&quot; title=&quot;엔티티 타입&quot;&gt;&lt;/a&gt;엔티티 타입&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;@Entity로 정의하는 객체!&lt;/li&gt;
&lt;li&gt;엔티티는 데이터가 변해도 식별자로 지속해서 추적이 가능해! 너무 당연한거지&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;

&lt;h2 id=&quot;값-타입&quot;&gt;&lt;a href=&quot;#값-타입&quot; class=&quot;headerlink&quot; title=&quot;값 타입&quot;&gt;&lt;/a&gt;값 타입&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체&lt;/li&gt;
&lt;li&gt;식별자가 없고 값만 있기에 변경시 추적이 불가능 해!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;갑 타입에 대해 알아보자!!&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA 영속성 전이(CASECADE)와 고아객체에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/08/11/jpa_cascade_orphan/"/>
    <id>https://devk0ng.github.io/2021/08/11/jpa_cascade_orphan/</id>
    <published>2021-08-10T17:28:54.001Z</published>
    <updated>2021-08-10T17:30:23.642Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;JPA-영속성-전이-CASECADE-와-고아객체&quot;&gt;&lt;a href=&quot;#JPA-영속성-전이-CASECADE-와-고아객체&quot; class=&quot;headerlink&quot; title=&quot;JPA 영속성 전이(CASECADE)와 고아객체&quot;&gt;&lt;/a&gt;JPA 영속성 전이(CASECADE)와 고아객체&lt;/h1&gt;&lt;h1 id=&quot;영속성-전이-CASECADE&quot;&gt;&lt;a href=&quot;#영속성-전이-CASECADE&quot; class=&quot;headerlink&quot; title=&quot;영속성 전이 (CASECADE)&quot;&gt;&lt;/a&gt;영속성 전이 (CASECADE)&lt;/h1&gt;&lt;p&gt;영속성 전이란 특정 &lt;strong&gt;엔티리를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때&lt;/strong&gt; 사용하면 되는 개념이야&lt;/p&gt;
&lt;p&gt;예를 들어 부모 엔티티를 persist할 때 자동으로 자식 엔티티도 함께 persist 시키고 싶을 때 말이지!&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA 프록시와 즉시로딩, 지연로딩에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/08/11/jpa_proxy_eager_lazy/"/>
    <id>https://devk0ng.github.io/2021/08/11/jpa_proxy_eager_lazy/</id>
    <published>2021-08-10T17:25:20.639Z</published>
    <updated>2021-08-10T17:30:49.229Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;프록시와-즉시로딩-지연로딩&quot;&gt;&lt;a href=&quot;#프록시와-즉시로딩-지연로딩&quot; class=&quot;headerlink&quot; title=&quot;프록시와 즉시로딩, 지연로딩&quot;&gt;&lt;/a&gt;프록시와 즉시로딩, 지연로딩&lt;/h1&gt;&lt;h1 id=&quot;프록시&quot;&gt;&lt;a href=&quot;#프록시&quot; class=&quot;headerlink&quot; title=&quot;프록시&quot;&gt;&lt;/a&gt;프록시&lt;/h1&gt;&lt;p&gt;지연로딩에 대해 이야기를 하기위해서는 프록시에 대해 먼저 알아야해!&lt;/p&gt;
&lt;p&gt;프록시가 무엇이냐??&lt;/p&gt;
&lt;p&gt;쉽게 말하면 &lt;strong&gt;가짜 엔티티&lt;/strong&gt;라고 생각할 수 있어&lt;/p&gt;
&lt;p&gt;EntityManger를 통해 프록시 객체를 조회하기 위해서는 em.getReference() 메소드를 이용할 수 있어!! 그러면 프록시를 가져와!!&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA 상속관계 매핑에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/08/09/jpa_inheritance_mapping/"/>
    <id>https://devk0ng.github.io/2021/08/09/jpa_inheritance_mapping/</id>
    <published>2021-08-08T16:23:36.862Z</published>
    <updated>2021-08-08T16:25:46.840Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;상속관계-매핑이란&quot;&gt;&lt;a href=&quot;#상속관계-매핑이란&quot; class=&quot;headerlink&quot; title=&quot;상속관계 매핑이란&quot;&gt;&lt;/a&gt;상속관계 매핑이란&lt;/h1&gt;&lt;p&gt;: 먼저 데이터 베이스는 원래는 상속 관계를 지원하지 않아!! But 슈퍼타입-서브타입이라는 모델링 기법이 존재하고 이녀석이 객체 상속과 비슷하게 생겼어!! 이를 이용해서 상속관계를 나타내보자!! 이렇게 된거지&lt;/p&gt;
&lt;p&gt;그래서 &lt;strong&gt;상속관계 매핑은 객체의 상속구조와 데이터베이스의 슈퍼타입-서브타입 관계를 매핑하는거야!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;여기에는 크게 3가지 전략이 있어&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;조인전략&lt;/li&gt;
&lt;li&gt;단일 테이블 전략&lt;/li&gt;
&lt;li&gt;구현 클래스마다 테이블 전략&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 3가지에 대해 알아볼거야. 참고로 어떤 전략을 쓰던 jpa에서는 상관없이 전부 매핑이 가능해.&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA 연관관계 매핑에 대해 알아보자</title>
    <link href="https://devk0ng.github.io/2021/08/02/jpa_relation_mapping/"/>
    <id>https://devk0ng.github.io/2021/08/02/jpa_relation_mapping/</id>
    <published>2021-08-01T16:47:18.961Z</published>
    <updated>2021-08-01T16:52:10.625Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;연관관계-용어정리와-간단한-설명&quot;&gt;&lt;a href=&quot;#연관관계-용어정리와-간단한-설명&quot; class=&quot;headerlink&quot; title=&quot;연관관계 용어정리와 간단한 설명&quot;&gt;&lt;/a&gt;연관관계 용어정리와 간단한 설명&lt;/h2&gt;&lt;p&gt;연관관계 매핑을 알아보기에 앞서 기본적인 용어를 정리하고 들어간당&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;방향 - 단방향, 양방향&lt;/li&gt;
&lt;li&gt;다중성 - 다대일, 일대다, 일대일, 다대다&lt;/li&gt;
&lt;li&gt;연관관계의 주인 - 양방향 관계에서는 연관관계 주인이라는 것을 설정해줘야해!! 중요!!&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;

&lt;h3 id=&quot;방향-별-사용방법&quot;&gt;&lt;a href=&quot;#방향-별-사용방법&quot; class=&quot;headerlink&quot; title=&quot;방향 별 사용방법&quot;&gt;&lt;/a&gt;방향 별 사용방법&lt;/h3&gt;&lt;p&gt;단뱡향은 그냥 @OneToMany, @ManyToOne … 등 관계를 나타내는 어노테이션과 @JoinColumn(name = “blabla”) 를 통해 외래키를 매핑해주고 그냥 사용하면 돼!!&lt;/p&gt;
&lt;p&gt;but, &lt;strong&gt;양방향의 경우에는 두 관계중 연관관계의 주인을 결정해 줘야해!!&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA와 기본 키 매핑에 관하여</title>
    <link href="https://devk0ng.github.io/2021/07/30/jpa_key_mapping/"/>
    <id>https://devk0ng.github.io/2021/07/30/jpa_key_mapping/</id>
    <published>2021-07-29T16:53:26.359Z</published>
    <updated>2021-07-29T16:55:31.090Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;JPA-기본-키-매핑&quot;&gt;&lt;a href=&quot;#JPA-기본-키-매핑&quot; class=&quot;headerlink&quot; title=&quot;JPA 기본 키 매핑&quot;&gt;&lt;/a&gt;JPA 기본 키 매핑&lt;/h1&gt;&lt;p&gt;기본키를 매핑하려면 @Id 어노테이션을 필드위에 선언해주면 돼!!&lt;/p&gt;
&lt;p&gt;추가적으로 @GeneratedValue라는 어노테이션과 함께 많이 사용하는데 이 어노테이션에 대해 알아보자!!&lt;/p&gt;
&lt;p&gt;먼저 기본 키 매핑 방법에는 두가지가 있어!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;직접할당과 자동생성&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>자주 사용되는 lombok, 주의 사항</title>
    <link href="https://devk0ng.github.io/2021/07/30/lombok/"/>
    <id>https://devk0ng.github.io/2021/07/30/lombok/</id>
    <published>2021-07-29T16:40:55.964Z</published>
    <updated>2021-07-29T16:42:33.478Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Getter-Setter&quot;&gt;&lt;a href=&quot;#Getter-Setter&quot; class=&quot;headerlink&quot; title=&quot;@Getter, @Setter&quot;&gt;&lt;/a&gt;@Getter, @Setter&lt;/h2&gt;&lt;p&gt;: 말그대로 getter, setter method를 생성해주는 놈이야!&lt;/p&gt;
&lt;p&gt;AccessLevel을 명시해줌으로써 접근제한자를 지정 해 줄 수 있어.&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="https://devk0ng.github.io/categories/spring/"/>
    
    
    <category term="spring" scheme="https://devk0ng.github.io/tags/spring/"/>
    
    <category term="lombok" scheme="https://devk0ng.github.io/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>앤티티 매핑(매핑 어노테이션 정리) 정리</title>
    <link href="https://devk0ng.github.io/2021/07/27/entity-mapping/"/>
    <id>https://devk0ng.github.io/2021/07/27/entity-mapping/</id>
    <published>2021-07-26T15:53:59.630Z</published>
    <updated>2021-07-28T15:53:22.666Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;객체와-테이블-매핑-관련-어노테이션&quot;&gt;&lt;a href=&quot;#객체와-테이블-매핑-관련-어노테이션&quot; class=&quot;headerlink&quot; title=&quot;객체와 테이블 매핑 관련 어노테이션&quot;&gt;&lt;/a&gt;객체와 테이블 매핑 관련 어노테이션&lt;/h1&gt;&lt;p&gt;객체와 테이블 매핑에 대해 먼저 알아보자!&lt;/p&gt;
&lt;h2 id=&quot;Entity&quot;&gt;&lt;a href=&quot;#Entity&quot; class=&quot;headerlink&quot; title=&quot;@Entity&quot;&gt;&lt;/a&gt;@Entity&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;@Entity가 붙은 클래스는 jpa가 관리하는 녀석이고 엔티티라고 한다.&lt;/li&gt;
&lt;li&gt;JPA를 사용해서 테이플과 매핑할&lt;/li&gt;
&lt;li&gt;name이라는 속성을 지정해 줄 수 있는데 이는 jpa에서 사용할 엔티티 이름이구 기본값은 클래스 이름을 그대로 사용해! (왠만하면 기본값을 사용)&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="entity" scheme="https://devk0ng.github.io/tags/entity/"/>
    
  </entry>
  
  <entry>
    <title>Saga Pattern이란?(Orchestration and Choreography)</title>
    <link href="https://devk0ng.github.io/2021/07/27/saga_pattern/"/>
    <id>https://devk0ng.github.io/2021/07/27/saga_pattern/</id>
    <published>2021-07-26T15:53:57.552Z</published>
    <updated>2021-07-28T13:48:09.414Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;2-Phase-Commit&quot;&gt;&lt;a href=&quot;#2-Phase-Commit&quot; class=&quot;headerlink&quot; title=&quot;2-Phase Commit&quot;&gt;&lt;/a&gt;2-Phase Commit&lt;/h1&gt;&lt;p&gt;우선 먼저 MSA구조 이전에는 분산 데이터베이스에 대해 어떻게 트랜잭션을 만족시켰는지 보자!!&lt;/p&gt;
&lt;p&gt;이때는 &lt;strong&gt;2-Phase Commit&lt;/strong&gt;이라는 방법을 사용했어!!&lt;/p&gt;
&lt;p&gt;참고로 사용하는 데이터베이스가 분산 트랜젝션을 지원해야 사용할 수 있는 방법이야!! (같은 종류의 데이터베이스이어야 하기에 MSA구조에는 적합하지 않겠지)&lt;/p&gt;</summary>
    
    
    
    <category term="Saga" scheme="https://devk0ng.github.io/categories/Saga/"/>
    
    
    <category term="msa" scheme="https://devk0ng.github.io/tags/msa/"/>
    
    <category term="saga pattern" scheme="https://devk0ng.github.io/tags/saga-pattern/"/>
    
    <category term="saga" scheme="https://devk0ng.github.io/tags/saga/"/>
    
    <category term="2pc" scheme="https://devk0ng.github.io/tags/2pc/"/>
    
    <category term="2 phase commit" scheme="https://devk0ng.github.io/tags/2-phase-commit/"/>
    
  </entry>
  
  <entry>
    <title>MSA와 API GATEWAY의 개념</title>
    <link href="https://devk0ng.github.io/2021/07/27/msa-and-api_gateway/"/>
    <id>https://devk0ng.github.io/2021/07/27/msa-and-api_gateway/</id>
    <published>2021-07-26T15:53:49.838Z</published>
    <updated>2021-07-28T13:29:59.041Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Monolitich-Architecture&quot;&gt;&lt;a href=&quot;#Monolitich-Architecture&quot; class=&quot;headerlink&quot; title=&quot;Monolitich Architecture&quot;&gt;&lt;/a&gt;Monolitich Architecture&lt;/h1&gt;&lt;p&gt;먼저 MSA를 알기위해서는 모노리틱 아키텍쳐를 알아야해!!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;모노티릭 아키텍쳐란?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;기존의 전통적인 웹 시스템 개발 스타일이고 하나의 어플리케이션 내에 모든 로직들이 모두~ 들어가있는 그런 통짜구조라고 생각하면 돼.&lt;/p&gt;</summary>
    
    
    
    <category term="msa" scheme="https://devk0ng.github.io/categories/msa/"/>
    
    
    <category term="msa" scheme="https://devk0ng.github.io/tags/msa/"/>
    
    <category term="gateway" scheme="https://devk0ng.github.io/tags/gateway/"/>
    
    <category term="api gateway" scheme="https://devk0ng.github.io/tags/api-gateway/"/>
    
  </entry>
  
  <entry>
    <title>다형성과 SOLID, 그리고 Spring</title>
    <link href="https://devk0ng.github.io/2021/07/27/polymorphism_and_solid_and_spring/"/>
    <id>https://devk0ng.github.io/2021/07/27/polymorphism_and_solid_and_spring/</id>
    <published>2021-07-26T15:49:09.663Z</published>
    <updated>2021-07-29T16:34:38.683Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;다형성-Polymorphism&quot;&gt;&lt;a href=&quot;#다형성-Polymorphism&quot; class=&quot;headerlink&quot; title=&quot;다형성(Polymorphism)&quot;&gt;&lt;/a&gt;다형성(Polymorphism)&lt;/h1&gt;&lt;br/&gt;

&lt;p&gt;&lt;strong&gt;다형성&lt;/strong&gt;은 객체지향의 특징 중 하나이다!&lt;br&gt;쉽게 말해 하나의 객체가 여러가지 타입을 가질 수 있는 것을 의미해.&lt;/p&gt;
&lt;p&gt;딱 위의 개념을 자바 문법에 대입해 보면 한가지 떠오르는 놈이 있지! 바로~ 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조하는 것!! 또는 인터페이스로 그 구현체를 참조하는 것!!&lt;/p&gt;
&lt;p&gt;실세계와 객체 지향이 완전히 1:1로 매칭이 되는 것은 아니나 역할과 구현을 분리해서 생각하면 실세계를 통해 다형성을 이해하기 수월해!!&lt;/p&gt;
&lt;p&gt;한가지 예를 들어볼게!!&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="https://devk0ng.github.io/categories/spring/"/>
    
    
    <category term="polymorphism" scheme="https://devk0ng.github.io/tags/polymorphism/"/>
    
    <category term="solid" scheme="https://devk0ng.github.io/tags/solid/"/>
    
    <category term="spring" scheme="https://devk0ng.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>API Composition vs CQRS Pattern</title>
    <link href="https://devk0ng.github.io/2021/07/27/api_composition_and_cqrs/"/>
    <id>https://devk0ng.github.io/2021/07/27/api_composition_and_cqrs/</id>
    <published>2021-07-26T15:49:07.495Z</published>
    <updated>2021-07-27T16:07:45.103Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;API-Composition과-CQRS-등장배경&quot;&gt;&lt;a href=&quot;#API-Composition과-CQRS-등장배경&quot; class=&quot;headerlink&quot; title=&quot;API Composition과 CQRS 등장배경&quot;&gt;&lt;/a&gt;API Composition과 CQRS 등장배경&lt;/h1&gt;&lt;p&gt;마이크로서비스로 전체 구성을 하였다고 가정을 해보자!&lt;br/&gt;특정 서비스를 제공하는 녀석을 A라고 가정해본닷. 그리고 A로 전달된 클라이언트의 request를 처리하기 위해서는 A친구는 다른 마이크로서비스 B,C,D에서 제공하는 정보를 조합해서 클라이언트에게 최종적인 결과를 주어야한닷&lt;/p&gt;
&lt;p&gt;이때, 이 상황에서 사용할 수 있는 방법이 2가지 존재해!!&lt;/p&gt;
&lt;p&gt;바로~ API Composition과 CQRS야!!&lt;/p&gt;</summary>
    
    
    
    <category term="msa" scheme="https://devk0ng.github.io/categories/msa/"/>
    
    
    <category term="msa" scheme="https://devk0ng.github.io/tags/msa/"/>
    
    <category term="cqrs" scheme="https://devk0ng.github.io/tags/cqrs/"/>
    
    <category term="api" scheme="https://devk0ng.github.io/tags/api/"/>
    
    <category term="composition" scheme="https://devk0ng.github.io/tags/composition/"/>
    
    <category term="API_Composition" scheme="https://devk0ng.github.io/tags/API-Composition/"/>
    
  </entry>
  
  <entry>
    <title>CQRS 패턴이란?</title>
    <link href="https://devk0ng.github.io/2021/07/27/cqrs/"/>
    <id>https://devk0ng.github.io/2021/07/27/cqrs/</id>
    <published>2021-07-26T15:49:05.385Z</published>
    <updated>2021-07-28T14:23:38.120Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;CQRS란&quot;&gt;&lt;a href=&quot;#CQRS란&quot; class=&quot;headerlink&quot; title=&quot;CQRS란&quot;&gt;&lt;/a&gt;CQRS란&lt;/h1&gt;&lt;p&gt;CQRS는 &lt;strong&gt;Command Query Responsibility Segregation&lt;/strong&gt; 의 약자이다!&lt;br&gt;명령 조회 책임 분리 패턴이라는 의미 그대로 받아들이면 제일 좋을 것 같다!!&lt;br/&gt;잠깐, 여기서 Command(명령)은 데이터의 변화를 주는 입력, 수정, 삭제 관련 작업들이라 볼 수 있고 Query는 조회와 관련된 작업이라 보면 된다! 즉 시스템 상태를 변경하냐 마냐의 유무라고 생각하면 될 것 같넹&lt;/p&gt;</summary>
    
    
    
    <category term="msa" scheme="https://devk0ng.github.io/categories/msa/"/>
    
    
    <category term="msa" scheme="https://devk0ng.github.io/tags/msa/"/>
    
    <category term="cqrs" scheme="https://devk0ng.github.io/tags/cqrs/"/>
    
  </entry>
  
  <entry>
    <title>영속성 컨택스트(Persistence Context)란?</title>
    <link href="https://devk0ng.github.io/2021/07/27/persistence_context/"/>
    <id>https://devk0ng.github.io/2021/07/27/persistence_context/</id>
    <published>2021-07-26T15:49:01.319Z</published>
    <updated>2021-07-28T13:44:49.978Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;영속성-컨텍스트란&quot;&gt;&lt;a href=&quot;#영속성-컨텍스트란&quot; class=&quot;headerlink&quot; title=&quot;영속성 컨텍스트란&quot;&gt;&lt;/a&gt;영속성 컨텍스트란&lt;/h1&gt;&lt;p&gt;JPA에서 가장 중요한 것을 두가지 뽑으라면 객체와 관계형 데이터베이스의 매핑과 &lt;strong&gt;영속성 컨텍스트&lt;/strong&gt;를 뽑을 수 있을 것 같다!!&lt;/p&gt;
&lt;p&gt;EntityManager는 요청마다 생겨서 database에 대한 connection을 얻은 후 database에 필요한 작업을 한다!!&lt;/p&gt;
&lt;p&gt;이때 EntityManager 객체 em에 대해 em.persist()를 하면 database에 insert가 된다고 생각을 하고있으나&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
    <category term="persistence" scheme="https://devk0ng.github.io/tags/persistence/"/>
    
    <category term="persistence context" scheme="https://devk0ng.github.io/tags/persistence-context/"/>
    
  </entry>
  
  <entry>
    <title>JPA는 왜 등장했는가?</title>
    <link href="https://devk0ng.github.io/2021/07/27/why_jpa/"/>
    <id>https://devk0ng.github.io/2021/07/27/why_jpa/</id>
    <published>2021-07-26T15:48:58.207Z</published>
    <updated>2021-07-28T13:38:35.145Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;JPA-등장배경&quot;&gt;&lt;a href=&quot;#JPA-등장배경&quot; class=&quot;headerlink&quot; title=&quot;JPA 등장배경&quot;&gt;&lt;/a&gt;JPA 등장배경&lt;/h1&gt;&lt;p&gt;JPA가 등장하게 된 배경이 무엇일까??&lt;br/&gt;객체를 관계형 데이터베이스에 저장하기 위해서는 중간에서 변환해주는 작업이 필요해!!&lt;/p&gt;
&lt;p&gt;WHY?&lt;/p&gt;
&lt;p&gt;객체와 관계형 데이터베이스간에는 해소하지 못하는 차이점이 존재해!!&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>JPA의 사용방법에 대해</title>
    <link href="https://devk0ng.github.io/2021/07/27/how_to_use_jpa/"/>
    <id>https://devk0ng.github.io/2021/07/27/how_to_use_jpa/</id>
    <published>2021-07-26T15:35:34.072Z</published>
    <updated>2021-07-27T16:21:15.253Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;데이터베이스-방언&quot;&gt;&lt;a href=&quot;#데이터베이스-방언&quot; class=&quot;headerlink&quot; title=&quot;데이터베이스 방언&quot;&gt;&lt;/a&gt;데이터베이스 방언&lt;/h1&gt;&lt;p&gt;jpa 사용법을 이야기하기에 앞서 좋은 점 하나를 끄적이고 시작하겠다 이말이야~&lt;/p&gt;
&lt;p&gt;데이터베이스에는 방언이라는 놈이 존재해!!&lt;/p&gt;
&lt;p&gt;그게 뭐신디!? 각각의 데이터베이스가 제공하는 SQL문법과 함수는 조금씩 달라!! (가변문자를 보면 MYSQL : VARCHAR, ORACLE : VARCHAR2)&lt;/p&gt;
&lt;p&gt;이처럼 &lt;strong&gt;SQL 표준을 지키지 않은 특정 데이터베이스만의 고유한 기능을 방언&lt;/strong&gt;이라고 하는데 &lt;strong&gt;JPA는 이에 종속적이지 않아!!&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/categories/jpa/"/>
    
    
    <category term="jpa" scheme="https://devk0ng.github.io/tags/jpa/"/>
    
    <category term="orm" scheme="https://devk0ng.github.io/tags/orm/"/>
    
  </entry>
  
</feed>
