<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="진정한 rest란?"><meta name="keywords" content="rest"><meta name="author" content="Sungbin Hong"><meta name="copyright" content="Sungbin Hong"><title>진정한 rest란? | devk0ng's blog</title><link rel="shortcut icon" href="/img/icon2.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="canonical" href="https://devk0ng.github.io/2022/01/23/real_rest/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3745226285485669',
  enable_page_level_ads: 'true'
});
</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"LK74G203SS","apiKey":"82b60d701a0005a22c7f6e2476b74ac1","indexName":"myblog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="devk0ng's blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%A7%84%EC%A0%95%ED%95%9C-REST%EB%9E%80"><span class="toc-number">1.</span> <span class="toc-text">진정한 REST란?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REST%EB%9E%80"><span class="toc-number">2.</span> <span class="toc-text">REST란?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#REST%EB%8A%94-%EC%99%9C-%EB%93%B1%EC%9E%A5%ED%95%98%EA%B2%8C-%EB%90%9C-%EA%B2%83%EC%9D%BC%EA%B9%8C"><span class="toc-number">2.1.</span> <span class="toc-text">REST는 왜 등장하게 된 것일까?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REST%EC%9D%98-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4"><span class="toc-number">3.</span> <span class="toc-text">REST의 제약조건</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Client-Server"><span class="toc-number">3.1.</span> <span class="toc-text">Client - Server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stateless"><span class="toc-number">3.2.</span> <span class="toc-text">Stateless</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache"><span class="toc-number">3.3.</span> <span class="toc-text">Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Uniform-Interface"><span class="toc-number">3.4.</span> <span class="toc-text">Uniform Interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Layered-System"><span class="toc-number">3.5.</span> <span class="toc-text">Layered System</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-On-Demand-optional"><span class="toc-number">3.6.</span> <span class="toc-text">Code On Demand (optional)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%98%84%EC%9E%AC%EC%9D%98-REST-API"><span class="toc-number">4.</span> <span class="toc-text">현재의 REST API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B7%B8%EB%9F%BC-%EC%9C%84%EC%9D%98-Uniform-Interface%EB%A5%BC-%EA%BC%AD-%EC%A7%80%EC%BC%9C%EC%95%BC%ED%95%98%EB%8A%94%EA%B0%80"><span class="toc-number">4.1.</span> <span class="toc-text">그럼 위의 Uniform Interface를 꼭 지켜야하는가??</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%98%84%EC%9E%AC%EB%8A%94-%EC%99%9C-%EC%A7%80%EC%BC%9C%EC%A7%80%EA%B8%B0-%EC%96%B4%EB%A0%A4%EC%9A%B4-%EA%B2%83%EC%9D%B4%EB%A9%B0-%EC%A7%80%ED%82%A4%EA%B8%B0-%EC%9C%84%ED%95%B4%EC%84%9C%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C"><span class="toc-number">4.2.</span> <span class="toc-text">현재는 왜 지켜지기 어려운 것이며 지키기 위해서는 어떻게 해야할까?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#web-vs-api"><span class="toc-number">4.2.1.</span> <span class="toc-text">web vs api</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML-VS-JSON"><span class="toc-number">4.2.2.</span> <span class="toc-text">HTML VS JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EA%B7%B8%EB%9F%BC-json%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-rest-api%EB%A5%BC-%EB%A7%8C%EB%93%A4%EA%B3%A0%EC%9E%90-%ED%95%9C%EB%8B%A4%EB%A9%B4"><span class="toc-number">4.2.3.</span> <span class="toc-text">그럼 json을 이용하여 rest api를 만들고자 한다면</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/icon2.png"></div><div class="author-info__name text-center">Sungbin Hong</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">34</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/background2.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">devk0ng's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">진정한 rest란?</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/rest/">rest</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="진정한-REST란"><a href="#진정한-REST란" class="headerlink" title="진정한 REST란?"></a>진정한 REST란?</h1><h1 id="REST란"><a href="#REST란" class="headerlink" title="REST란?"></a>REST란?</h1><p>Representational State Transfer의 줄임말로 Roy T. Fielding에 의해 만들어진 개념이다!</p>
<p>이는 분산 하이퍼 미디어 시스템을(웹) 위한 아키텍쳐 스타일이고 제약조건의 집합이라고 볼 수 있어!!</p>
<p>즉 rest를 만족하기 위한 조건들이 존재하고 이를 만족하였을 때 rest 구조를 따른다라고 이야기할 수 있는거지</p>
<p>각 제약조건들의 핵심은 결국 interoperability를 만족하자! 라고 생각할 수 있어. 즉 상호운영성을 가지게 하자라는거지. </p>
<p>조금 더 깊이 이해하기위해 발생하게 된 역사를 한번 보자!</p>
<span id="more"></span>
<p><br><br></p>
<h2 id="REST는-왜-등장하게-된-것일까"><a href="#REST는-왜-등장하게-된-것일까" class="headerlink" title="REST는 왜 등장하게 된 것일까?"></a>REST는 왜 등장하게 된 것일까?</h2><p>1991년에 WEB이 등장했지. 그리고 이에 맞게 정보를 주고받는 규약들이 만들어졌지.</p>
<p>결과적으로 모든 정보들을 하이퍼텍스트로 연결을 시켰어.</p>
<p>그리고 URI라는 식별자를 통해 HTTP를 이용하여 HTML을 주고받는거지!!</p>
<p>Rest의 탄생의 시초는 Roy T. Fielding의 Http Object Model에서 나왔어. 그리고 이는 당시에 존재하던 web architecture sytle에서 조금 더 좋은 구조를 만들기 위해 제약조건들을 추가해 나갔고 그렇게해서 만들어진게 REST라는 개념이 된거야.</p>
<p><br><br><br></p>
<h1 id="REST의-제약조건"><a href="#REST의-제약조건" class="headerlink" title="REST의 제약조건"></a>REST의 제약조건</h1><p>그럼 제약조건들에 대해 알아보자</p>
<p><br><br></p>
<h2 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client - Server"></a>Client - Server</h2><p>첫번째로 추가된 조건은 client-server architectural style이야. 해당 조건의 핵심은 관심사의 분리야. User Interface의 문제를 Data Storage 문제와 분리를 시켜 여러 플랫폼에서 User Interface 즉 사용자 인터페이스의 이식성을 개선한거지. 그리고 분리를 해줌으로써 서버의 구성요소가 간단해지며 그에 따른 확장성을 얻기 쉬워진거야.</p>
<p>이렇게 분리를 해줌으로써 독립적인 발전을 가능하게 만들어 주었어.</p>
<p><br><br></p>
<h2 id="Stateless"><a href="#Stateless" class="headerlink" title="Stateless"></a>Stateless</h2><p>다음으로 추가된 조건은 Client-Server의 Interaction 즉 상호작용에 추가된거야! 커뮤니케이션은 Stateless 해야한다!</p>
<p>이말은 Client에서 서버로가는 각 request 들은 그 request안에 필요한 모든 정보를 포함하고 있어야지, 이 정보들이 Server에 저장된 어떠한 context에 의해 도움을 받아선 안된다는거야. 쉽게 설명하면 Server는 각 Client의 상태, 정보등을 저장하여 요청을 처리하는데 이점을 받으면 안된다는거지.</p>
<p>이렇게 해줌으로써 Visibility, Reliability, Scalability 측면에서 이점을 얻을 수 있ㄷ어.</p>
<ol>
<li>Visibility - Monitoring System이 request 전체의 특성을 파악하기 위해서 단일 request를 넘어서 볼일이 없어. 즉 request 하나만 보아도 request 마다 상태를 server에서 저장하는 것이 아니니 알 수 있다는거지.</li>
<li>Reliability - 부분적인 failures 로부터 복구작업을 쉽게 해줘. </li>
<li>Scalability - server 측에서 요청 사이에 state를 저장할 필요가 없으니 resource에 대한 free 즉 해제가 쉬워지고 요청사이에 state를 저장할 필요가 없다는 이점은 구현을 간단화 시켜주게 되는거야.</li>
</ol>
<p><br><br></p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>network의 efficiency 즉 효율성을 높이기 위해 cache constraint를 추가! </p>
<p>이는 response에 담겨있는 data에 cacheable의 여부를 담고 cacheable의 경우 client에서는 동일한 request에 대해 data를 재사용할 권한을 갖게하는거지!</p>
<p>user가 느끼는 performance 측면에서 분명 큰 효과가 있으나 trade-off 관계인 것이 cache의 data가 server 측 실 data와 일치한지에 대한 reliability 측면에서는 또 떨어뜨리는 효과가 발생할 수 있어. (물론 그런 reliability를 처리하는 방안까지 현재 conditional get 처럼 나와있기는 하지)</p>
<p><br><br></p>
<h2 id="Uniform-Interface"><a href="#Uniform-Interface" class="headerlink" title="Uniform Interface"></a>Uniform Interface</h2><p>uniform interface 는 구성요소간의 균일한 인터페이스를 가진다는 것이 주된 내용이야. 이를통해 전체 시스템 아키텍쳐가 단순화되는 효과를 볼 수 있으며 상호작용의 가시성 또한 좋아지지!</p>
<p>그리고 이를통해 제공하는 서비스와는 분리된 상태로 implementation을 발전시킬 수 있어. 한마디로 독립적인 발전을 가능하게 해준다는거지.</p>
<p>이러한 Uniform Interface를 만족시키기 위해서는 component들의 behavior에 대해 여러 제한들이 더 요구되어져</p>
<ul>
<li>identification of resources - resource가 uri로 식별되면 된다</li>
<li>manipulation of resources through representations - http message에 resource에 대한 동작의 표현을 담아 전송을 하여 동작하게 끔 한다</li>
<li>self-descriptive messages</li>
<li>hypermedia as the engine of application state (HATEOAS)</li>
</ul>
<p><br><br></p>
<h2 id="Layered-System"><a href="#Layered-System" class="headerlink" title="Layered System"></a>Layered System</h2><p>internet-scale의 요구사항들에 대한 동작, 즉 규모가 큰 구조에서 성능 향상을 위해 Layered System Constraints를 추가했어. 각 layer는 자신들의 knowledge 즉 담당하는 정도가 제한되어져있고 여기서 오는 이점이 전체적인 시스템의 복잡도를 제한시키고 독립성을 높여줘.</p>
<p>그리고 이를 통해 legacy service들에 대해 캡슐화가 가능해지고 legacy client로 부터 새로운 서비스를 보호할 수 있데. </p>
<p>그리고 intermediary 즉, 중개자 역할을 하는 layer 에서 로드밸런싱을 수행해 scalability를 높일 수도 있으며 서비스에서 자주 사용되지 않는 기능들에 대해서도 해당 layer에 넣어 component들을 단순화 시키는 등의 이점을 볼 수 있지.</p>
<p><br><br></p>
<h2 id="Code-On-Demand-optional"><a href="#Code-On-Demand-optional" class="headerlink" title="Code On Demand (optional)"></a>Code On Demand (optional)</h2><p>서버에서 코드를 클라이언트로 보내서 실행할 수 있어야한다. (Javascript)</p>
<p><br><br><br></p>
<h1 id="현재의-REST-API"><a href="#현재의-REST-API" class="headerlink" title="현재의 REST API"></a>현재의 REST API</h1><p>REST API는 말그대로 REST 구조를 따라가는 api야. 현재 REST를 지키지 않으면서 REST API라고 이야기하는 경우가 많데. Roy T. Fiedling 아저씨가 이를 싫어한다고 하시네.. ㅠㅠ</p>
<p>우선 HTTP만 만족시켜도 위의 대부분 조건들을 잘 지킬 수 있으나 Uniform Interface 조건을 지키기가 어려워.</p>
<p>Uniform Interface의 제약사항들 중에서도 self-descriptive-messages 와 hateoas…</p>
<ul>
<li>self-descriptive messages - 메시지가 스스로를 설명해야해. 메시지를 봤을 때 그 내용만으로 전체 해석이 가능해야해</li>
<li>hypermedia as the engine of application state(hateoas) - 어플리케이션의 상태는 항상 하이퍼링크를 이용해 전이되어야해. (html의 a태그, json의 Link헤더 등..)</li>
</ul>
<p>위의 두가지에 대해 조금 더 설명을 하자면 self-descriptive는 확장 가능한 커뮤니케이션을 제공해줘. 서버나 클라이언트가 변경되더라도 오고가는 메시지는 언제나 self-descriptive하기에 언제나 해석이 가능해.</p>
<p>hateoas는 어플리케이션 상태 전이의 late binding을 가능하게 해줘. 즉 어디서 어디로 전이가 가능한지 미리 결정되지 않는거야. 어떤 상태로 전이가 완료되고 나서야 그 다음 전이될 수 있는 상태가 결정되는거지. 결과적으로 링크는 동적으로 변경될 수 있게 되는거야!</p>
<p><br><br></p>
<h2 id="그럼-위의-Uniform-Interface를-꼭-지켜야하는가"><a href="#그럼-위의-Uniform-Interface를-꼭-지켜야하는가" class="headerlink" title="그럼 위의 Uniform Interface를 꼭 지켜야하는가??"></a>그럼 위의 Uniform Interface를 꼭 지켜야하는가??</h2><p>rest를 지키려한다면 지켜주는게 맞아!!</p>
<p>uniform interface는 <strong>독립적인진화</strong>를 위해 필요해. 서버와 클라이언트는 독립적으로 진화하며 서버의 기능이 변경되더라도 클라이언트를 업데이트할 필요가 없지.</p>
<p>interoperability 즉 상호운용성을 굉장히 중요하게 생각하기에 이전에 잘못 지었던 오타들이나 415 상태코드 등 잘못된 부분들을 고치는 것을 포기하는거야. 그만큼 이런 상호적인 측면을 중요하게 생각해. 어떤 변경이 있을 때 전체적인 상호작용에 문제가 생기는 것을 굉장히 싫어해.</p>
<p>이러한 이유들로 REST라면 Uniform Interface를 지켜주는 것이 맞아.</p>
<p><br><br></p>
<h2 id="현재는-왜-지켜지기-어려운-것이며-지키기-위해서는-어떻게-해야할까"><a href="#현재는-왜-지켜지기-어려운-것이며-지키기-위해서는-어떻게-해야할까" class="headerlink" title="현재는 왜 지켜지기 어려운 것이며 지키기 위해서는 어떻게 해야할까?"></a>현재는 왜 지켜지기 어려운 것이며 지키기 위해서는 어떻게 해야할까?</h2><br>

<h3 id="web-vs-api"><a href="#web-vs-api" class="headerlink" title="web vs api"></a>web vs api</h3><p>우선 Rest를 잘 적용했다는 web과 api의 차이점을 보자</p>
<table>
<thead>
<tr>
<th></th>
<th>웹</th>
<th>HTTP API</th>
</tr>
</thead>
<tbody><tr>
<td>Protocol</td>
<td>HTTP</td>
<td>HTTP</td>
</tr>
<tr>
<td>커뮤니케이션</td>
<td>사람-기계</td>
<td>기계-기계</td>
</tr>
<tr>
<td>Media Type</td>
<td>HTML</td>
<td>JSON</td>
</tr>
</tbody></table>
<p>위에서 볼 수 있듯이 가장 큰 차이는 media type 즉 데이터 포맷이야. 웹피이지의 경우 사람과의 상호작용으로 html을 통해 정보를 보여주지만 http api의 경우 기계와 기계간의 상호작용이고 그렇기에 기계가 알아들을 수 있는 json을 써!</p>
<p>그럼 이 둘은 무엇이 다를까?</p>
<table>
<thead>
<tr>
<th></th>
<th>HTML</th>
<th>JSON</th>
</tr>
</thead>
<tbody><tr>
<td>Hyperlink</td>
<td>가능(a tag)</td>
<td>정의되어 있지 않다</td>
</tr>
<tr>
<td>Self-Descriptive</td>
<td>가능(HTML 명세)</td>
<td>불완전 해</td>
</tr>
</tbody></table>
<p>html은 hyperlink(a태그), self-descriptive(html 명세)가 돼!!<br>json은 hyperlink 정의되어있지 않고, self-descriptive가 불완전해.(어떻게 파싱할지는 정해져있으나 그안에 값의 의미는 알 수 없어). 그래서 우리가 맨날 api 문서를 만드는 것이지</p>
<br>

<h3 id="HTML-VS-JSON"><a href="#HTML-VS-JSON" class="headerlink" title="HTML VS JSON"></a>HTML VS JSON</h3><ul>
<li>HTML<ol>
<li>HTML은 Self-Descriptive를 만족해. 응답 메시지의 content-type을 보고 media type이 text/html임을 확인할 수 있지</li>
<li>HTTP 명세에 media type은 INNA에 등록되어 있다 하므로, INNA에서 text/html에 대한 설명을 찾을 수 있어.</li>
<li>이렇게 타고타고 들어가면 결국 모든 태그의 설명들을 하고있는 명세를 볼 수 있거 해당 응답을 해석하는 것이 가능하게 되는거야!!</li>
<li>hateoas 측면에서도 a태그로 표현된 링크를 통해 다음 상태로 전이할 수 있기에 만족해</li>
</ol>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /todos HTTP/1.1</span><br><span class="line">Host: example.org</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://todos/1&quot;</span>&gt;</span>회사 가기<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://todos/2&quot;</span>&gt;</span>집에 가기<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JSON<ol>
<li>명세를 통해 json을 파싱할 수는 있겠지만 결국 아래 데이터에서 id가 뭔지 title이 뭔지 그 의미를 알 수는 없어. 그렇기에 self-descriptive하지 못한거지</li>
<li>hateoas 또한 불만족해</li>
</ol>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /todos HTTP/<span class="number">1.1</span></span><br><span class="line">Host: example.org</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;<span class="attr">&quot;id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;회사 가기&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">&quot;id&quot;</span>: <span class="number">2</span>, <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;집에 가기&quot;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<br>

<h3 id="그럼-json을-이용하여-rest-api를-만들고자-한다면"><a href="#그럼-json을-이용하여-rest-api를-만들고자-한다면" class="headerlink" title="그럼 json을 이용하여 rest api를 만들고자 한다면"></a>그럼 json을 이용하여 rest api를 만들고자 한다면</h3><ul>
<li>media type을 등록하는 방법이 있어. INNA에 직접 media type과 그 명세를 작성하여 등록하는 것이지.</li>
<li>혹은 json 데이터의 의미를 정의한 명세를 작성하고 link 헤더에 profile relation으로 해당 명세를 링크해. 그럼 메시지를 보는 사람은 명세를 찾아갈 수 있으니 문서의 의미를 온전히 해석 가능하게 되는거지</li>
<li>hateoas를 만족하기 위해서는 그 다음 이동해야하는 하이퍼링크를 data에 넣어서 표현해버리면 돼!! 혹은 헤더를 활용할 수도 있고!!!</li>
</ul>
<p><br><br><br><br><br><br></p>
<blockquote>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.youtube.com/watch?v=RP_f5dMoHFc">https://www.youtube.com/watch?v=RP_f5dMoHFc</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://velog.io/@codemcd/RESTREpresentational-State-Transfer-hgk2muj4l2">https://velog.io/@codemcd/RESTREpresentational-State-Transfer-hgk2muj4l2</a></p>
</blockquote>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/rest/">rest</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/01/25/git_branch_merge/"><i class="fa fa-chevron-left">  </i><span>git branch와 merge의 기초</span></a></div><div class="next-post pull-right"><a href="/2022/01/21/spring_interceptor/"><span>Spring Web Mvc Interceptors란</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a9fadaa0c71177598341',
  clientSecret: '677df1a9ceea07288fecd99348d15054f5659172',
  repo: 'devk0ng.github.io',
  owner: 'devk0ng',
  admin: 'devk0ng',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/background2.png)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By Sungbin Hong</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="external nofollow noopener noreferrer" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>