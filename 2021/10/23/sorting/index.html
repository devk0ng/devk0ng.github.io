<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="여러 정렬에 대해 알아보자"><meta name="keywords" content="sorting,algorithm"><meta name="author" content="Sungbin Hong"><meta name="copyright" content="Sungbin Hong"><title>여러 정렬에 대해 알아보자 | devk0ng's blog</title><link rel="shortcut icon" href="/img/icon2.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="canonical" href="https://devk0ng.github.io/2021/10/23/sorting/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3745226285485669',
  enable_page_level_ads: 'true'
});
</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"LK74G203SS","apiKey":"82b60d701a0005a22c7f6e2476b74ac1","indexName":"myblog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="devk0ng's blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%97%AC%EB%9F%AC-%EC%A2%85%EB%A5%98%EC%9D%98-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EB%B3%BC-%EB%95%8C-%EB%B9%84%EA%B5%90-%EA%B8%B0%EC%A4%80"><span class="toc-number">1.</span> <span class="toc-text">여러 종류의 정렬 알고리즘을 볼 때 비교 기준</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A2%85%EB%A5%98"><span class="toc-number">2.</span> <span class="toc-text">정렬 알고리즘 종류</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC-Selection-Sort"><span class="toc-number">2.1.</span> <span class="toc-text">선택정렬(Selection Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9B%90%EB%A6%AC"><span class="toc-number">2.1.1.</span> <span class="toc-text">원리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BD%94%EB%93%9C"><span class="toc-number">2.1.2.</span> <span class="toc-text">코드</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8A%B9%EC%84%B1"><span class="toc-number">2.1.3.</span> <span class="toc-text">특성</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC-Insertion-Sort"><span class="toc-number">2.2.</span> <span class="toc-text">삽입 정렬(Insertion Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9B%90%EB%A6%AC-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">원리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BD%94%EB%93%9C-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">코드</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8A%B9%EC%84%B1-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">특성</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%B2%84%EB%B8%94-%EC%A0%95%EB%A0%AC-Bubble-Sort"><span class="toc-number">2.3.</span> <span class="toc-text">버블 정렬(Bubble Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9B%90%EB%A6%AC-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">원리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BD%94%EB%93%9C-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">코드</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8A%B9%EC%84%B1-2"><span class="toc-number">2.3.3.</span> <span class="toc-text">특성</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%95%A9%EB%B3%91-%EC%A0%95%EB%A0%AC-Merge-Sort"><span class="toc-number">2.4.</span> <span class="toc-text">합병 정렬(Merge Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9B%90%EB%A6%AC-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">원리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BD%94%EB%93%9C-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">코드</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8A%B9%EC%84%B1-3"><span class="toc-number">2.4.3.</span> <span class="toc-text">특성</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%80%B5-%EC%A0%95%EB%A0%AC-Quick-Sort"><span class="toc-number">2.5.</span> <span class="toc-text">퀵 정렬(Quick Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9B%90%EB%A6%AC-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">원리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BD%94%EB%93%9C-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">코드</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8A%B9%EC%84%B1-4"><span class="toc-number">2.5.3.</span> <span class="toc-text">특성</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%9E%99-%EC%A0%95%EB%A0%AC-Heap-Sort"><span class="toc-number">2.6.</span> <span class="toc-text">힙 정렬(Heap Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9B%90%EB%A6%AC-5"><span class="toc-number">2.6.1.</span> <span class="toc-text">원리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8A%B9%EC%84%B1-5"><span class="toc-number">2.6.2.</span> <span class="toc-text">특성</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%89%98-%EC%A0%95%EB%A0%AC-Shell-Sort"><span class="toc-number">2.7.</span> <span class="toc-text">쉘 정렬(Shell Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9B%90%EB%A6%AC-6"><span class="toc-number">2.7.1.</span> <span class="toc-text">원리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8A%B9%EC%84%B1-6"><span class="toc-number">2.7.2.</span> <span class="toc-text">특성</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/icon2.png"></div><div class="author-info__name text-center">Sungbin Hong</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">36</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">14</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/background2.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">devk0ng's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">여러 정렬에 대해 알아보자</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/sorting/">sorting</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="여러-종류의-정렬-알고리즘을-볼-때-비교-기준"><a href="#여러-종류의-정렬-알고리즘을-볼-때-비교-기준" class="headerlink" title="여러 종류의 정렬 알고리즘을 볼 때 비교 기준"></a>여러 종류의 정렬 알고리즘을 볼 때 비교 기준</h1><ol>
<li>Stable vs Unstable : 만약 정렬하고자 하는 대상의 크기가 같은 경우, 대상들의 순서가 보장이 되는지(stable) 안되는지(unstable)</li>
<li>In-place vs out-of-place : input에 대해 extra memory 없이 transform한다(in-place), 그렇지 않다 (out-of-place)</li>
<li>시간복잡도, 공간복잡도</li>
</ol>
<span id="more"></span>

<p><br><br><br></p>
<h1 id="정렬-알고리즘-종류"><a href="#정렬-알고리즘-종류" class="headerlink" title="정렬 알고리즘 종류"></a>정렬 알고리즘 종류</h1><br>

<h2 id="선택정렬-Selection-Sort"><a href="#선택정렬-Selection-Sort" class="headerlink" title="선택정렬(Selection Sort)"></a>선택정렬(Selection Sort)</h2><br>

<h3 id="원리"><a href="#원리" class="headerlink" title="원리"></a>원리</h3><p>: 선택정렬 알고리즘은 장소를 먼저 선택한다고 생각하면 좋을 것 같다!</p>
<p><img src="https://gmlwjd9405.github.io/images/algorithm-selection-sort/selection-sort.png"></p>
<p>위의 그림처럼 먼저 첫번 째 자리(장소)를 선택 후 해당 자리에 어떤 숫자를 넣을지 찾는 것이다. 그리고 이 과정을 첫번째 자리, 두번째 자리.. N번째 자리까지 찾으면 정렬이 완료되는 것이다!</p>
<p>오름차순 정렬을 원한다면, 첫번 째 자리부터 계산을 할 때 작은 값을 선택하면 되는 것이고</p>
<p>내림차순 정렬을 원한다면, 큰 값을 선택해 나가면서 자리를 채워주면 되는 것이지.</p>
<br>

<h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;arr.<span class="built_in">size</span>() ; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> cur = i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span> ; j&lt;arr.<span class="built_in">size</span>() ; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j] &lt; arr[cur])</span><br><span class="line">				cur = j;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">swap</span>(arr[i], arr[cur]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="특성"><a href="#특성" class="headerlink" title="특성"></a>특성</h3><ul>
<li>위 코드에서 볼 수 있듯이 시간복잡도는 O(N^2)이다.</li>
<li>정렬을 위한 추가적인 공간이 필요없는 in-place sorting이다!</li>
<li>Unstable Sort이다!! 자리를 찾아가는 과정에서 동일한 값에 대한 순서가 지켜지지 않을 수 있어</li>
</ul>
<p><br><br></p>
<h2 id="삽입-정렬-Insertion-Sort"><a href="#삽입-정렬-Insertion-Sort" class="headerlink" title="삽입 정렬(Insertion Sort)"></a>삽입 정렬(Insertion Sort)</h2><br>

<h3 id="원리-1"><a href="#원리-1" class="headerlink" title="원리"></a>원리</h3><p>: 삽입정렬은 현재 보고 있는 위치가 있다면, 그 위치의 전에 위치한 애들을 쭈욱 보면서 현재 위치의 값이 어디에 들어가는 것이 맞는지를 찾아 넣는 알고리즘이다.</p>
<p>조금 더 쉽게 말하자면 1 2 5 4 인 상태에서 현재 보고 있는 위치가 index로는 3인 4라는 값을 보고 있다고 하자. 그럼 5 → 2 → 1 이렇게 차례대로 보면서 4가 어디에 들어가는지를 찾아낸다는 말이다!!</p>
<p>5를 보았을 때는 4보다 크니 pass, 2를 보았을 때는 4보다 작으니 stop!! 결국 2와 5사이가 4가 들어갈 자리라는 것을 알 수 있다</p>
<p><img src="https://gmlwjd9405.github.io/images/algorithm-insertion-sort/insertion-sort.png"></p>
<br>

<h3 id="코드-1"><a href="#코드-1" class="headerlink" title="코드"></a>코드</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;arr.<span class="built_in">size</span>() ; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> targetIdx;</span><br><span class="line">		<span class="keyword">int</span> targetNum = arr[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(targetIdx=i<span class="number">-1</span> ; targetIdx&gt;=<span class="number">0</span> ; targetIdx--) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[targetIdx] &lt; arr[i]) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		targetIdx +=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i ; j&gt;targetIdx ; j--) &#123;</span><br><span class="line">			arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[targetIdx] = targetNum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//처음에는 위처럼 나는 짰지만 더 효율적이게 짤 수 있다</span></span><br><span class="line"><span class="comment">//아래처럼 말이야</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;arr.<span class="built_in">size</span>() ; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> targetNum = arr[i];</span><br><span class="line">		<span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(j=i<span class="number">-1</span> ; j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;targetNum ; j--) &#123;</span><br><span class="line">			arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr[j+<span class="number">1</span>] = targetNum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="특성-1"><a href="#특성-1" class="headerlink" title="특성"></a>특성</h3><ul>
<li>위 보이는 것 처럼 O(N^2)이다! 시간복잡도는 worst case를 계산하기 때문이지!! 그러나 정렬이 거의 되어있다고 생각해봐!! 최선의 경우 O(N)만에 가능하게 되어져!</li>
<li>추가적인 공간이 필요없으므로 in-place sort 야!!</li>
<li>동일한 크기의 값에 대해 들어온 순서를 지킬 수 있게 구현할 수 있으므로 stable sort야!</li>
</ul>
<p><br><br></p>
<h2 id="버블-정렬-Bubble-Sort"><a href="#버블-정렬-Bubble-Sort" class="headerlink" title="버블 정렬(Bubble Sort)"></a>버블 정렬(Bubble Sort)</h2><br>

<h3 id="원리-2"><a href="#원리-2" class="headerlink" title="원리"></a>원리</h3><p>: 매번 연속된 두개 인덱스를 비교해서, 정한 기준에 의해 두 인덱스의 값을 바꿀지 말지를 비교하는거야.</p>
<p>예를들어, 오름차순이라면 첫번째 인덱스부터 차례대로 인접한 두 인덱스를 비교하여 큰 값이 상대적으로 왼쪽에 있는 경우 두 인덱스의 값을 바꾸어 준다!</p>
<p>이렇게 되면 한바퀴를 다 돌고 난 이후면 맨 오른쪽 위치에는 해당 수들 중 가장 큰 수가 있게 될 것이고 이러한 작업을 반복하면 결국 정렬이 완성되는 것이다.</p>
<p><img src="https://gmlwjd9405.github.io/images/algorithm-bubble-sort/bubble-sort.png" alt="https://gmlwjd9405.github.io/images/algorithm-bubble-sort/bubble-sort.png"></p>
<br>

<h3 id="코드-2"><a href="#코드-2" class="headerlink" title="코드"></a>코드</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=arr.<span class="built_in">size</span>()<span class="number">-1</span> ; i&gt;<span class="number">0</span> ; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ; j&lt;i ; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">				<span class="built_in">swap</span>(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="특성-2"><a href="#특성-2" class="headerlink" title="특성"></a>특성</h3><ul>
<li>추가적인 공간이 필요없는 in-place sorting!</li>
<li>O(N^2)의 시간복잡도!</li>
<li>stable sort야!!</li>
</ul>
<p><br><br></p>
<h2 id="합병-정렬-Merge-Sort"><a href="#합병-정렬-Merge-Sort" class="headerlink" title="합병 정렬(Merge Sort)"></a>합병 정렬(Merge Sort)</h2><br>

<h3 id="원리-3"><a href="#원리-3" class="headerlink" title="원리"></a>원리</h3><p>: 배열이 주어졌을 때 해당 배열을 크기가 1이 될 때 까지 계속해서 반으로 분할(divide) 해 나가!!</p>
<p>그리고 더이상 나누지 못하는 상태가 왔을 때 다시 합쳐나가는거지!! 이때 합쳐나갈 때는 정렬을 시키면서 합쳐나가는거야!!</p>
<p><img src="https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort-concepts.png" alt="https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort-concepts.png"></p>
<p>이렇게 말이야</p>
<br>

<h3 id="코드-3"><a href="#코드-3" class="headerlink" title="코드"></a>코드</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> lt, <span class="keyword">int</span> rt, vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(arr.size())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lt &lt; rt) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (lt+rt)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">mergeSort</span>(lt, mid, arr);</span><br><span class="line">		<span class="built_in">mergeSort</span>(mid+<span class="number">1</span>, rt, arr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> p1 = lt, p2 = mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> tempPtr = lt;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= rt) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[p1] &lt; arr[p2])</span><br><span class="line">				temp[tempPtr++] = arr[p1++];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				temp[tempPtr++] = arr[p2++];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(p1 &lt;= mid)</span><br><span class="line">			temp[tempPtr++] = arr[p1++];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(p2 &lt;= rt)</span><br><span class="line">			temp[tempPtr++] = arr[p2++];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=lt ; i&lt;=rt ; i++)</span><br><span class="line">			arr[i] = temp[i];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="특성-3"><a href="#특성-3" class="headerlink" title="특성"></a>특성</h3><ul>
<li>시간복잡도는 O(NlogN) 이다</li>
<li>Stable Sort야!!</li>
<li>데이터가 배열 자료구조에 들어가져 있다면 임시 배열이 필요해!! 즉, out-of-place sort야!!</li>
<li>그러나 데이터가 연결리스트로 구현되어 있을 경우 in-place sort 야!! 왜냐하면 연결 링크만 바꾸면서 병합하면 되기 때문이지</li>
<li>분할정복의 한 종류야</li>
</ul>
<p><br><br></p>
<h2 id="퀵-정렬-Quick-Sort"><a href="#퀵-정렬-Quick-Sort" class="headerlink" title="퀵 정렬(Quick Sort)"></a>퀵 정렬(Quick Sort)</h2><br>

<h3 id="원리-4"><a href="#원리-4" class="headerlink" title="원리"></a>원리</h3><p>: 퀵 정렬 또한 분할 정복의 한 종류인데 pivot 이라는 기준이 되는 값을 설정 후 이 값을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 나누는 작업을 반복하며 정렬하는 sorting 알고리즘이야!</p>
<br>

<h3 id="코드-4"><a href="#코드-4" class="headerlink" title="코드"></a>코드</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> lt, <span class="keyword">int</span> rt, vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[lt];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = lt;</span><br><span class="line">	<span class="keyword">int</span> j = rt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">while</span>(pivot &lt; arr[j])</span><br><span class="line">			j--;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(i &lt; j &amp;&amp; pivot &gt;= arr[i])</span><br><span class="line">			i++;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arr[lt] = arr[i];</span><br><span class="line">	arr[i] = pivot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> lt, <span class="keyword">int</span> rt, vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lt &gt;= rt)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pi = <span class="built_in">partition</span>(lt, rt, arr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">quickSort</span>(lt, pi<span class="number">-1</span>, arr);</span><br><span class="line">	<span class="built_in">quickSort</span>(pi+<span class="number">1</span>, rt, arr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="특성-4"><a href="#특성-4" class="headerlink" title="특성"></a>특성</h3><ul>
<li>시간복잡도는 평균 O(NlogN)이나 최악의 경우 O(N^2)이 될 수 있어! 언제 최악이 되냐?? 배열이 정렬이 되어있을 수록 효율성은 떨어지지!!</li>
<li>퀵정렬은 최악이 O(N^2)인데도 빠른 정렬로 분류되는 이유가 무엇인가?? 사실 오히려 O(NlogN)보다 더 빠른 성능을 보일 때도 많아</li>
<li>이는 pivot을 어떻게 설정하느냐에 따라 좌우되어지는 것이고 보통 랜덤으로 하는 방법을 선택하나 left, right를 통해 mid 값을 뽑아내서 최악의 case를 피할수도 있어!</li>
<li>Unstable Sort야!!</li>
</ul>
<p><br><br></p>
<h2 id="힙-정렬-Heap-Sort"><a href="#힙-정렬-Heap-Sort" class="headerlink" title="힙 정렬(Heap Sort)"></a>힙 정렬(Heap Sort)</h2><br>

<h3 id="원리-5"><a href="#원리-5" class="headerlink" title="원리"></a>원리</h3><p>: 완전 이진트리를 기본으로 하는 힙 자료구조를 기반으로 한 정렬이야</p>
<p>오름차순 정렬을 원할 때는 최소 힙을 사용하고 내림차순 정렬을 원할 때는 최대 힙을 사용해!</p>
<p>힙에 대해서는 따로 정리를 하는 것으로 하자!</p>
<br>

<h3 id="특성-5"><a href="#특성-5" class="headerlink" title="특성"></a>특성</h3><ul>
<li>O(NlogN)이라는 시간 복잡도를 가지고 있어! 완전이진트리인 힙 자료구조를 이용하기에 요소를 힙에 삽입하거나 혹은 삭제하여 재정비할 때 logN만큼의 시간이 들지! 그리고 요소의 갯수가 N이니 O(NlogN)이 나오는거야</li>
<li>당연히 Unstable Sort야!!</li>
<li>정렬을 위한 extra memory는 필요 없기에 in-place sort야!</li>
</ul>
<p><br><br></p>
<h2 id="쉘-정렬-Shell-Sort"><a href="#쉘-정렬-Shell-Sort" class="headerlink" title="쉘 정렬(Shell Sort)"></a>쉘 정렬(Shell Sort)</h2><br>

<h3 id="원리-6"><a href="#원리-6" class="headerlink" title="원리"></a>원리</h3><p>: 쉘정렬은 삽입정렬을 보완한 알고리즘이야. 삽입정렬이 언제 효율지 좋다 했는지 기억이 나는가!? 위에 적혀있겠지만 거의 정렬이 된 상태에서 효율이 최대로 나오지.</p>
<p>이런 아이디어에서 나온 것이 쉘 정렬이야. 전체적으로 어느정도 정렬된 상태로 만든 후 삽입정렬을 하는 거지!!</p>
<p>구체적으로는 <strong>간격(gap)을</strong> 구해서 그 간격만큼의 위치에 있는 원소들을 추출해서 각각의 부분리스트를 만들고 그 각각에 대해 정렬을 한 후 새로이 gap을 설정하고 반복하는 거지!!</p>
<p>그러다 gap이 1이 되었을 때는 삽입정렬 한번 시행하면 모든 요소들이 정렬된 상태로 나오게 되는 것이지!</p>
<p><img src="https://gmlwjd9405.github.io/images/algorithm-shell-sort/shell-sort.png"></p>
<p>이런식으로 되어지는거야!</p>
<p>간격의 초기값은 (정렬할 값의 수)/2로 구할 수 있어. 그 이후 각각의 간격에 대해 /2 연산을 진행하면서 구해나가면 돼! 이때, 간격은 홀수로 하는 것이 좋기에 간격/2 연산의 결과가 짝수라면 +1을 해줘!</p>
<br>

<h3 id="특성-6"><a href="#특성-6" class="headerlink" title="특성"></a>특성</h3><ul>
<li>평균적으로 O(N^1.5)의 시간복잡도를 가져!! Wort일 때는 삽입정렬과 동일하게 O(N^2) 이야</li>
</ul>
<p><br><br><br><br><br><br></p>
<blockquote>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html">https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html</a></p>
</blockquote>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/sorting/">sorting</a><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/10/24/data_structure/"><i class="fa fa-chevron-left">  </i><span>여러 자료구조에 대해 알아보자</span></a></div><div class="next-post pull-right"><a href="/2021/10/19/spring_data_jpa_paging_sort/"><span>스프링 데이터 JPA 페이징과 정렬에 대해 알아보자</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a9fadaa0c71177598341',
  clientSecret: '677df1a9ceea07288fecd99348d15054f5659172',
  repo: 'devk0ng.github.io',
  owner: 'devk0ng',
  admin: 'devk0ng',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/background2.png)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By Sungbin Hong</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="external nofollow noopener noreferrer" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>